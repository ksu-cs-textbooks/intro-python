




	
	
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		

	
	
		
		

	
	
		
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		

	
	
		

	
	
		
		
		

	
	
		

	
	
		
		
		
		

	
	
		

	
	
		
		
		

	
	
		
[
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Basic Python",
    "uri": "/01-basic-python/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Numbers \u0026 Math",
    "uri": "/02-numbers/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Strings \u0026 Input",
    "uri": "/03-strings-input/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Conditionals",
    "uri": "/04-conditionals/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Loops",
    "uri": "/05-loops/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Functions",
    "uri": "/06-functions/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Lists",
    "uri": "/07-lists/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Dictionaries",
    "uri": "/08-dictionaries/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Classes",
    "uri": "/09-classes/"
  },
  {
    "content": " Resources Slides The Python programs we’ve written up to this point are very static - each time we run the program, it will perform the same exact operations. Since we’re running these programs on a real computer, it might be helpful to build programs that can read and respond to input from the user, making them much more useful overall. Python includes many different ways to handle user input, but in this lab we’ll just focus on the simple input() function.\nInput in Python The input() function is used to display a prompt the user and then record input. Let’s look at a quick example:\nname = input(\"Enter your name: \") print(\"Hello \", end=\"\") print(name) Here, we see that the input() function actually accepts a message as an argument, which will be displayed to the user. After the message is printed, the user will be given a cursor to enter text immediately after it. Once the user presses the ENTER key, the input() function will read the input that was entered and store it as a string value or str data type in the variable called name.\nFor example, if the user inputs Willie Wildcat at the prompt, this program’s output will look like this:\nEnter your name: Willie Wildcat Hello Willie Wildcat We can see this even more clearly in the terminal. When we first run the program, we’ll see the prompt \"Enter your name:\" printed, followed by a cursor prompting the user to enter something:\nOnce the user types the input and presses ENTER, the rest of the program will run:\nNow we see the cursor is at the next command prompt, ready to run another program.\n",
    "description": "",
    "tags": null,
    "title": "Input",
    "uri": "/03-strings-input/01-input/"
  },
  {
    "content": " Resources Slides So far, we’ve only worked with string values in Python. Strings are a very useful data type in programming languages such as Python, but they are very limited in their use. Recall that a data type simply defines how a particular value is stored in a computer. The str data type is used to store string values in Python.\nPython supports many different data types for handling various data that we’d like to store and manipulate in our programs. In this lab, we’re going to cover the two basic types used for storing numbers in Python, the int or integer type, and the float or floating-point type.\nIntegers In mathematics, an integer is a whole number, such as $ 3 $, $ -5 $, or even $ 0 $. Basically, any positive or negative number that doesn’t include a fractional or decimal portion is a whole number, and therefore it is an integer. In Python, those numbers can be stored in the int data type.\nIn Python, we can store an integer value in a variable using an assignment statement:\nx = 5 That statement will store the integer value $ 5 $ in the variable x. Notice that the value $ 5 $ does not have quotation marks around it. This is because we want to store the integer value $ 5 $ and not the string value \"5\" in the variable. Also, as we learned earlier, this is why we cannot create variable names that begin with a number - since numerical values start with a number, this is how Python can tell the difference between a numerical value and a variable.\nWe can also store negative numbers in a variable by placing a negative symbol - in front of the numerical value:\ny = -8 We’ll need to be careful and make sure that there is a space after the equals sign =, but no space between the negative symbol - and the number after it. Otherwise, the negative symbol could be confused for the minus symbol, which is an operator that we’ll learn about later in this lab.\nIn Python, there is effectively no maximum size for an integer, so we can store any arbitrarily large whole number (either positive or negative) in an int variable.\n",
    "description": "",
    "tags": null,
    "title": "Integers",
    "uri": "/02-numbers/01-integers/"
  },
  {
    "content": " Resources Slides In this lab, we’re going to introduce another data type in Python, the Boolean data type. Working with Boolean values in programming is a very important skill to learn.\nElsewhere in this course, we’ve already learned about Boolean values and how they work, so we won’t cover that information again here. Feel free to refer to other areas in this course for more background on Booleans, Boolean Logic, Boolean Algebra, and other related topics.\nIn this lab, we’ll learn how to create Boolean values in Python, as well as the various Boolean operators and comparators that can we can use in our code. Then, we’ll explore how to use conditional statements to affect the control flow of our programs. This allows us to build programs that will perform different tasks based on the input we receive from the user, which is a very key concept in programming. Let’s get to it!\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/04-conditionals/01-intro/"
  },
  {
    "content": " Resources Slides Over the last few labs, we’ve explored how we can change the control flow of our programs using conditional statements. A program that doesn’t contain any conditional statements will have a linear control flow. Each time we run the program, it will execute the same steps in the same order, but it may use different data based on input from the user.\nWhen a program contains a conditional statement, its control flow can split into different branches. This means that each program may take a different path through the program, but it will eventually reach the end. There is no way to go back and repeat a step that has already been done!\nIn this lab, we’re going to introduce the other important method for modifying the control flow of our programs - a loop or iteration statement. In programming, a loop is a construct that allows us to repeatedly execute the same piece of code, either for a set number of times, or while a particular Boolean condition is true. Each time we execute the code inside the loop, we call that an iteration of the loop.\nLoops are one of the most useful ways we can modify the control flow in our programs. With both loops and conditional statements in our list of available programming skills, we can write programs that execute different branches of code based on a Boolean expression, and we can also repeatedly execute the same piece of code either a defined number of times or while a Boolean expression evaluates to True. This allows us to build some truly useful programs.\nIn this lab, we’re going to explore ways to use loops in Python. Python supports two different types of loops, while loops and for loops, both of which can be used in a variety of different ways in our programs. We’ll also explore how to use these loops to receive input from the user and handle the case where a user provides invalid input, and finally we’ll look at some ways to test our code containing loops to confirm that they are working correctly and won’t cause issues.\nLet’s get started!\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/05-loops/01-intro/"
  },
  {
    "content": " Resources Slides Learning to program involves learning not only the syntax and rules of a new language, but also a new way of thinking. Not only do we want to write code that is understandable by the computer, we must also understand what the computer will do when it tries to run that code.\nA key part of that is learning to think like a computer thinks. We sometimes call this our “mental model” of a computer. If we have a good “mental model” of a computer, then we can learn to read code and mentally predict what it will do, even without ever running it on an actual computer. This ability is crucial for programmers to develop.\nSo, as we work through this lab, we’ll need to constantly pay attention to how a real computer works, and make sure that our “mental model” is accurate. If not, we’ll have to adapt our understanding of a computer to match the real world. This process of adaptation and accommodation is an important part of learning to program - we have to have a good understanding of what a computer actually does when it runs our code, or else we won’t be able to write code that will do what we want it to do.\nWe’ve chosen Python because it is very easy to learn, easy to use, and it is used in many different places, from scientific computing and data analysis to web servers and even artificial intelligence. It is a very useful language to learn, and it makes a great first programming language.\nAs we learn to write code in a real programming language, it helps to refer to the actual documentation from time to time. So, we recommend bookmarking the official Python Documentation as a great place to start. Throughout this course, we may also include links to additional resources, and those are also worth bookmarking. One of the best parts about programming is that nearly all of the documentation is online and easily accessible, and learning how to quickly search for a particular solution or reference is just as useful as knowing how to do it from memory. In fact, most programmers really only know the basics of the language and a few handy tricks, and the rest of it is just reading documentation and learning when to use it. So, don’t worry about remembering it all right from the start - instead, learn to read the documentation and use the tools that are available, and focus on understanding the basics of the language’s syntax and rules. Let’s get started!\n",
    "description": "",
    "tags": null,
    "title": "Learning to Program",
    "uri": "/01-basic-python/01-learning-to-program/"
  },
  {
    "content": " Resources Slides In Python, Boolean values are stored in the bool data type. Variables of the bool data type can only store one of two values, True or False. So, a Boolean value is really the simplest data value we can imagine - it is a single binary bit representing a value of True or False.\nTo create a Boolean variable in Python, we can simply assign those values to a variable in an assignment statement:\na = True b = False print(a) print(type(b)) When we execute that code, we’ll see the following output:\nTrue \u003cclass 'bool'\u003e In Python, we use the keywords True and False to represent Boolean values. In Python, it is very important to make sure these values are capitalized, otherwise the program will not work properly. Also, since these are keywords and not strings, we don’t need to put them in quotation marks.\nConverting Between Data Types Python includes the special bool() function, which can be used to convert any data type into a Boolean value. The bool() function follows these rules to determine what to return:\nIf the input is the value False, the value 0, the value None, or anything with 0 length, including the empty string, it will return False. Otherwise, for all other values it will return True. Let’s look at a couple of quick examples. First, let’s try to convert the strings \"True\" and \"False\" to their Boolean equivalents:\nprint(bool(\"True\")) print(bool(\"False\")) When this code is executed, we’ll see this output:\nTrue True This seems a bit strange, since the string \"False\" ended up creating the Boolean value True. However, if we look at the rules above, since the string \"False\" has a length greater than 1, and it is not any of the special values listed above, it should always result in the Boolean value True.\nIn this example, we can check a couple of special values using the bool() function:\nprint(bool(0)) print(bool(1)) print(bool(\"\")) In this case, we’ll see the following output:\nFalse True False Here, we see that the value 0, as well as the empty string \"\", both result in a value of False. However, the value 1 is True, since it is a non-zero value.\nIn practice, we won’t use the bool() function directly very often. Instead, if we want to determine if a user inputs a True or False value, we can just use one of the Boolean comparators that we’ll see later in this lab.\n",
    "description": "",
    "tags": null,
    "title": "Booleans",
    "uri": "/04-conditionals/02-booleans/"
  },
  {
    "content": " Resources Slides The other type of number we can store in Python is a floating-point number. We won’t go into too much detail about floating-point values here, since you’ll learn about them elsewhere in this class. For the purposes of programming, the only thing to know about floating-point numbers is that they are used to represent numbers that include a fractional or decimal portion. In Python, these values are stored in the float data type.\nTo create a variable that stores a floating-point value in Python, we can use an assignment statement that includes a value with a decimal point, like this:\na = 5.8 We can also create negative values using the negative symbol -:\nb = -7.987 Finally, it is possible to store a whole number in a floating-point value by simply adding a decimal point and a 0 at the end of the value, as in this example:\nc = 42.0 Later in this lab, we’ll see a couple of situations where that may be useful.\nFor now, we’re just going to assume that Python can easily handle any reasonable number we want it to store in a float variable, but there are some limits to the size and accuracy of those numbers. To reach these limits, we usually have to be dealing with numbers that have $ 100 $ or more digits, either before or after the decimal place. So, for the purposes of this class, those limits really won’t apply to what we’re doing. You’ll learn about these limits in detail in later programming classes.\n",
    "description": "",
    "tags": null,
    "title": "Floats",
    "uri": "/02-numbers/02-floats/"
  },
  {
    "content": " Resources Slides Of course, we can also read numerical input in Python using the input() function. To do this, we must simply use either the int() or float() function to convert the input received as a string to the correct data type.\nHere’s a quick example program that requires two inputs for the price and quantity of an item being purchased:\ntext_one = input(\"Enter the price of one item: \") price = float(text_one) text_two = input(\"Enter the quantity of items: \") quantity = int(text_two) cost = price * quantity print(\"The total cost is $\", end=\"\") print(cost) If the user wishes to purchase $ 3 $ items at the price of $ 2.75 $ per item, then the program’s output would look like this:\nEnter the price of one item: 2.75 Enter the quantity of items: 3 The total cost is $8.25 In the program, we simply read each input from the user as a string value, then use the appropriate conversion function to convert it to the correct data type. For numbers including a decimal point, we use float(), but for whole numbers we use the int() function.\nThis works well if the user enters values that make sense. But, what if the user wishes to purchase a fraction of an item? Will this program work? Unfortunately, if the user enters a value with a decimal point for the second input, it can no longer be converted to an integer and we’ll get an error:\nEnter the price of one item: 2.75 Enter the quantity of items: 3.5 Traceback (most recent call last): File \"tutor.py\", line 4, in \u003cmodule\u003e quantity = int(text_two) ValueError: invalid literal for int() with base 10: '3.5' For right now, there’s not much we can do about that error other than write programs that clearly tell the user what type of data is expected, but later we’ll learn how to handle errors like this and prompt the user for input again.\n",
    "description": "",
    "tags": null,
    "title": "Numerical Input",
    "uri": "/03-strings-input/02-number-input/"
  },
  {
    "content": " Resources Slides The first type of loop to explore in Python is the while loop. A while loop uses a Boolean expression, and will repeat the code inside of the loop as long as the Boolean expression evaluates to True. These loops are typically used when we want to repeat some steps, but we aren’t sure exactly how many times it must be done. Instead, we typically know that there is some condition that must be True while we repeat the code, and once it turns False we can stop looping and continue with the program.\nThe general syntax for a while loop in Python is shown here:\nwhile \u003cboolean expression\u003e: \u003cblock of statements\u003e Notice that this syntax is very similar to an if statement. We start with the keyword while, followed by some sort of a \u003cboolean expression\u003e that will evaluate to either True or False. The Boolean expression in Python does not need to be placed inside of parentheses. After the Boolean expression is a single colon :. Then, starting on the next line and indented one level is a \u003cblock of statements\u003e that will be executed when the Boolean expression evaluates to True. Once again, just like in an if statement, we know which statements are part of the block within a while loop based solely on indentation.\nIt is possible for the Boolean expression to evaluate to False initially, which will bypass the loop entirely and never execute the code inside of it. Likewise, if we aren’t careful, we can also write a loop where the Boolean expression will always be True, and the loop will run infinitely, causing our program to lock up and never terminate.\nCode Tracing Example To truly understand how a while loop works in Python, let’s go through a simple code tracing example in Python Tutor. Consider the following Python program:\nx = int(input(\"Enter a number from 0 to 100: \")) total = 0 while total % 100 != x: total = total + 9 print(f\"The smallest multiple of 9 that ends in {x} is {total}\") See if you can figure out what this program does before moving on!\nAs always, you can copy and paste this code into Python Tutor, or click this Python Tutor link.\nWhen we load this code in Python Tutor, we should see the usual default state. The first line of the program will prompt the user for input and store it in the variable x.\nFor this example, let’s assume the user inputs the string \"27\".\nTherefore, we’ll store the value $ 27 $ in the variable x.\nThe next line will store the value $ 0 $ in the variable total, as shown here:\nAt this point, we’ve reached the beginning of the while loop. So, we’ll need to determine if the Boolean expression evaluates to True or False. In this case, the value of total % 100 is equal to $ 0 $, so it is not equal to the value stored in x. Therefore, the Boolean expression is True, and we should enter the loop.\nInside of the loop, we are simply adding $ 9 $ to the value in total. So, we’ll see that variable is updated, and the execution pointer goes back to the top of the loop.\nNow that we are back at the top of the loop, we need to check the Boolean expression again. This time the value of total % 100 is $ 9 $, which still isn’t equal to the value stored in x, so we’ll enter the loop again.\nWe’ll add $ 9 $ to the total here, and jump to the top again.\nOnce again, we will check the Boolean expression and see that it is still True, so we’ll enter the loop and add $ 9 $ to the total yet again before repeating the process from the top of the loop. At this point, we should see this state in Python tutor.\nWhen we compute total % 100, we get the value $ 27 $, which is the same as the value stored in x. This will make the Boolean expression evaluate to False, so we can skip the loop and jump to the bottom of the program.\nHere, we are simply printing out the output, and then the program will terminate.\nA full animation of this program’s execution in Python Tutor is shown here.\nTracing the execution of a while loop is quite simple, especially with tools such as Python Tutor to help us make sure we’re updating the variables in the correct order.\n",
    "description": "",
    "tags": null,
    "title": "While Loops",
    "uri": "/05-loops/02-while-loops/"
  },
  {
    "content": " Resources Slides First, let’s start with the basics of writing Python code in a file and running those files. This is the first major step toward actually writing a real program, but it can definitely be difficult the first time without prior experience to rely on. So, let’s go through it step by step and make sure we know how to run our programs in Python.\nAt this point, we should already have Python installed on our system. For students using Codio, this is taken care of already. For students using their own computers, refer to an earlier lab to find instructions for installing Python on your system, or contact the instructors for assistance.\nTo make sure that Python is installed and working, we’ll need to open a terminal in our operating system. In Codio, this can be found by clicking the Tools menu at the top, and then choosing Terminal. More information can be found in the Codio Documentation. There may also already be one open for you if you are reading this content from within Codio.\nIf you are working on your own computer, you’ll need to open a terminal on your operating system. This should have been covered in the previous lab when you installed Python. On Windows, look for Windows Terminal or Windows PowerShell (not the old Command Prompt, which requires different commands). On Mac or Linux, look for an application called Terminal. Throughout this course, we’ll call these windows the terminal, even though they may have slightly different names in each operating system.\nOnce we have the terminal open, we should see something like one of these examples:\nAt this point, we should see a place with a blinking cursor, where we can type our commands. This is called the command prompt in the terminal. The first thing we can do is check to make sure Python is properly installed, and we can also confirm that it is the correct version. To do this, we’ll enter the following command and press enter to execute it:\npython3 --version Hopefully, that command should produce some output that looks like this:\nHere, we see that the currently installed Python version is 3.10.6. As long as your Python version number begins with a 3, you have correctly installed Python and are able to run it from the terminal. So, we can continue to the next part of this lab.\nIf you aren’t able to run Python or aren’t sure that you have the correct version, contact the instructor for assistance!\nPython 2 vs. Python 3 Notice that we have to use the command python3, including the version number, instead of the simpler python command here. This is because some systems may also have Python version 2, an outdated version of Python, installed alongside version 3. In that case, the simple python command will be Python version 2, while python3 will be Python version 3. Unfortunately, most programs written in Python 3 will not run properly in Python 2, so it is important for us to make sure we are using the correct Python version when running our programs.\nThankfully, the command python3 should always work, and using that command is a good habit to learn. So, throughout this course, we will use the command python3 to run Python programs.\nNavigating in the Terminal When we open a terminal, it will usually start in our user’s home folder. This may mean different locations for different operating systems. For example, if our current user’s name is \u003cusername\u003e, the terminal will usually start in this location for each operating system:\nWindows: C:\\Users\\\u003cusername\u003e Linux: /home/\u003cusername\u003e Mac: /Users/\u003cusername\u003e Codio: /home/codio/workspace The directory that is open in the terminal is known as the working directory. We can use the pwd command to determine what our current directory is:\nIn this example, we are looking at the Codio terminal, so our working directory is /home/codio/workspace.\nNext, we can see the files and directories contained in that directory using the ls command. Here’s the output of running this command in Codio:\nIn the output, we can see that there is a file named README.txt and a directory named python. In Codio, we’ll place all of our files in the python directory, so we can open that using the cd python command:\nNotice how the python directory is now included in the command prompt in the terminal. Most terminals will show the working directory in the command prompt in some way.\nThat’s the basics of navigating in the terminal, but there is much more to learn. If you’d like to know more, consider checking out some of the resources linked below!\nResources Basic Linux Navigation \u0026 File Management from DigitalOcean Beginner’s Guide to the Bash Terminal by Joe Collins on YouTube Windows \u0026 Mac Terminal Most of the content in this course will focus on using the commands that are present in the Linux terminal, since they are the most widely-used commands across all platforms. In general, these commands should work well on both Windows and Mac, with a few caveats:\nOn Windows, there is an older Command Prompt tool that does not support the newer Linux commands. Therefore, we won’t be using it. Instead, we only want to use Windows PowerShell, which supports most of the basic Linux commands via aliases to similar PowerShell commands. We can also install the Windows Terminal application for a more modern interface. Windows users may also choose to install the Windows Subsystem for Linux (WSL) to run Linux (such as Ubuntu) directly within Windows. Many developers choose to pursue this option, as it provides a clean and easy to use development environment that is compatible with the Linux operating system. The Mac operating system includes a terminal that uses either ZSH (since OS X 10.15) or Bash (OS X 10.14 and below). This terminal is very similar to the Linux terminal when it comes to navigating the file system and executing programs, which is sufficient for this course. Fully learning how to use these tools is outside of the scope of this class, but we need to know enough to navigate the filesystem and execute the python3 command. If you need assistance getting started with this step, your best bet is to contact the instructors. Each student’s computer is a bit different, so it is difficult to cover all possible cases here.\n",
    "description": "",
    "tags": null,
    "title": "Working in the Terminal",
    "uri": "/01-basic-python/02-working-in-terminal/"
  },
  {
    "content": " Resources Slides Python also includes several operators that can be applied to one or two Boolean values. These operators make up the basis of Boolean logic, and allow us to construct complex expressions of Boolean values. Let’s quickly review the three basic Boolean operators present in Python.\nAnd Operator In Python, we use the keyword and to perform the Boolean and operation. This operator will return True if both input values are also True, otherwise it will return False.\nThis corresponds to the following truth table:\nVariable 1 Variable 2 Result F F F F T F T F F T T T Here’s a quick example of the and operator in Python:\nx = True y = False print(x and y) When we run this Python code, we should see this output:\nFalse Since the variable y is False, the resulting value is also False.\nOr Operator Likewise, the keyword or is used in Python for the Boolean or operation. This operator will return True if either of the input values is True, but it will return False if neither of them are True.\nThis corresponds to the following truth table:\nVariable 1 Variable 2 Result F F F F T T T F T T T T Let’s look at an example:\na = False b = True print(a or b) When we execute this code, we’ll get this output:\nTrue Since b is True, we know that at least one input is True and the result of a or b is also True.\nNot Operator Finally, Python uses the keyword not to represent the Boolean not operation, which simply inverts a Boolean value from True to False and vice-versa.\nThis corresponds to the following truth table:\nVariable 1 Result F T T F Here’s an example:\nx = True print(not x) print(not not x) When we run this code, we’ll see this printed to the terminal:\nFalse True Since x is True, we know that not x is False. We can then perform the not operation again, on that result, as shown in not not x, which will result in the original value of x, which is True.\n",
    "description": "",
    "tags": null,
    "title": "Boolean Operators",
    "uri": "/04-conditionals/03-operators/"
  },
  {
    "content": " Resources Slides Python also includes a second type of loop that is very useful, the for loop. A for loop is used when we want to repeat the steps a certain number of times. However, in Python, we can’t just say that we want to repeat something $ 10 $ times. Instead, we use the built-in range() function in Python to generate a list of numbers that we use in our loop. Then, our for loop will repeat once for each number in the list, and we can even access that number using an iterator variable\nLists in Python We’ll learn more about lists in Python in a later lab. For now, we’re just going to use the range() function to generate them for use with for loops.\nRange Function The range() function can be used in three different ways, depending on the number of arguments given when calling the function:\nrange(stop) - with a single argument, the range() function will generate a list of numbers that begins at $ 0 $ and stops before it reaches the stop value. For example, range(10) will generate a list of numbers from $ 0 $ through $ 9 $. This is great, since there will be $ 10 $ numbers in total, so a for loop using range(10) will repeat $ 10 $ times. range(start, stop) - with two arguments, the range() function will generate a list of numbers that begins at start and stops before it reaches the stop value. So, range(3,8) will generate the list [3, 4, 5, 6, 7]. There will be stop - start numbers in the range. range(start, stop, step) - with three arguments, the range() function will generate a list of numbers that begins at start, increases by step each time, and stops before the stop value. Therefore, range(0, 10, 2) will generate the list [0, 2, 4, 6, 8]. We can also use a negative value for step to count backwards. So, range(5, 0, -1) will generate the list [5, 4, 3, 2, 1]. You can read more about the Python range() function in the Python Documentation\nFor Loops The general structure of a for loop in Python is shown here:\nfor \u003citerator variable\u003e in \u003clist\u003e: \u003cblock of statements\u003e The first time we reach a for loop, we’ll keep track of the \u003clist\u003e that we’ll be iterating over. In general, once you start repeating in a for loop, the \u003clist\u003e cannot be changed.\nIf the list contains at least one item, then we’ll store the first item in the list in the \u003citerator variable\u003e and enter the for loop to execute the code in the \u003cblock of statements\u003e When we reach the end of the block, we’ll jump back to the top and check to see if the \u003clist\u003e contains another item. If so, we’ll store that item in the \u003citerator variable\u003e and execute the code in the \u003cblock of statements\u003e again.\nThis process will repeat until we’ve used every item in the \u003clist\u003e. Then, we’ll jump to the end of the for loop and continue the program from there.\nCode Tracing Example To really see how a for loop works in Python, let’s use Python Tutor to trace through a quick sample program. Consider this Python program:\nx = int(input(\"Enter a number: \")) line = \"\" for i in range(x): line = line + \"*\" print(line) Before working through the code in Python Tutor, see if you can determine what this program does just by reading it!\nTo step through the code, we can load it into Python Tutor by copy and pasting it there, or by clicking this Python Tutor link.\nWe’ll start with the usual default state as shown here. The first line will read the input from the user.\nFor this example, let’s assume the user inputs the string \"5\":\nThis means that we’ll store the number $ 5 $ in the variable x. The program will also create an empty string value in the line variable, which we’ll use to generate output.\nAt this point, we should have reached the beginning of the for loop.\nBehind the scenes, Python will generate a list of numbers based on the range() function. Since the range() function is called with a single argument, we know it will be a list of numbers starting at $ 0 $ and ending before it reaches the value in x, which is $ 5 $. So, the list will contain the numbers [0, 1, 2, 3, 4], and it will cause the for loop to repeat $ 5 $ times. For the first iteration of the loop, Python will store the first number in the list, $ 0 $, in the iterator variable i. In programming, we typically use the variable name i to represent our iterator variable. So, once the program has entered the loop, we should see this state:\nInside of the loop, the first statement will update the line value by adding an asterisk * to the end of the string. So, after this statement is executed, the line variable will store a string containing a single asterisk.\nThe second statement will print the line variable to the output.\nAt this point, we’ve reached the end of the for loop, so our execution pointer jumps back up to the top of the loop. Then, we check to see if the list we are iterating through contains more values. Again, this list isn’t shown in Python tutor, so we have to mentally keep track, but we can see the current value in i, and we know what the list contains by looking at the range() function. So, we’ll update i to store the value $ 1 $, and repeat the loop once again.\nJust like before, this iteration will add an asterisk to the string in the line variable, and then print that to the output before repeating once again.\nThere are still more items in the list, so we’ll update i to the value $ 2 $ and enter the loop:\nIn the loop, we’ll update line to contain one more asterisk, and then print it before looping back to the top.\nThe list still isn’t empty, so we’ll update i to be $ 3 $ this time:\nAnd then we’ll update line and print it.\nBy now, we should have a pretty good idea of what this loop does. There’s one more item in the list, so we’ll update i to be $ 4 $:\nInside the loop, we’ll add one more asterisk to line and then print it.\nFinally, we’re back at the top of the loop. Since there are no more items left in the list, we can jump to the bottom of the for loop and continue the program from there.\nIn this case, there’s no more code left in the main() function, so it will end and the program will terminate.\nLooking at the output, we see that this program will print a right triangle of asterisks that is x lines tall and x characters wide at the bottom.\nA full execution of this program is shown in this animation.\nAs we can see, working with for loops in Python is a quick and easy way to repeat a block of statements a specific number of times using the range() function.\nConverting to a While Loop It is possible to convert any for loop using the range() function in Python to a while loop. This can be done following a simple three-step pattern:\nSet an initial value for the iterator variable before the loop Update the iterator value at the end of each loop iteration Convert to a while loop and check the ending value of the iterator variable in the Boolean expression Let’s look at the code from the example above:\nx = int(input(\"Enter a number: \")) line = \"\" for i in range(x): line = line + \"*\" print(line) To convert this for loop into a while loop, we can follow the three steps listed above. First, we must set an initial value for our iterator variable i before the loop. Since the first value stored in i is $ 0 $, we’ll set it to that value.\nx = int(input(\"Enter a number: \")) line = \"\" i = 0 for i in range(x): line = line + \"*\" print(line) Next, we need to update the value of the iterator variable at the end of each loop iteration. Since we didn’t provide an argument for the step value in the range() function, we know that i will just be incremented by $ 1 $ each time. So, we’ll add a short line to increment i at the bottom of the loop:\nx = int(input(\"Enter a number: \")) line = \"\" i = 0 for i in range(x): line = line + \"*\" print(line) i = i + 1 Finally, we can switch the for loop to a while loop. In the Boolean expression, we want to repeat the loop while the iterator variable i has not reached the maximum value. So, we’ll use the Boolean expression i \u003c x in the new while loop:\nx = int(input(\"Enter a number: \")) line = \"\" i = 0 while i \u003c x: line = line + \"*\" print(line) i = i + 1 There we go! That’s the basic process for converting any for loop using range() in Python to be a while loop. It’s a useful pattern to know and recognize when it is used in code.\n",
    "description": "",
    "tags": null,
    "title": "For Loops",
    "uri": "/05-loops/03-for-loops/"
  },
  {
    "content": " Resources Slides Before we learn to write our first program, let’s start by introducing some important vocabulary terms:\nstring: A string in programming is any text that is stored as a value. We typically represent strings by placing them inside double quotes \"\" in our code and elsewhere. value: A value is a piece of data that our program is storing and manipulating. In our pseudocode, values consist of either numbers or strings. keyword: A keyword is a reserved word in a programming language that defines a particular statement, expression, structure, or other use. As we’ll learn later, we cannot use these keywords as variable or procedure names. statement: A statement refers to a piece of code that performs an action, but doesn’t result in any value. Most complete lines of code are considered statements. expression: An expression, on the other hand, is a piece of code that, when evaluated, will result in a value that can be used or stored. An expression can even contain multiple expressions inside of it! We’ll use these terms to help us understand different parts of the code in our programs. Now that we’ve covered them them, we can start to discuss the various statements in Python.\nThe first statement that we’ll cover in the Python programming language is the print(expression) statement. This statement is used to display output to the user via the terminal. So, when Python runs this statement, it will evaluate the expression to a single value, and then print that value to the terminal.\nFor example, the simplest Python code would be a simple Hello World program, where we use the print(expression) statement to display the text \"Hello World\" to the user:\nprint(\"Hello World\") Notice that the expression part of the statement contains \"Hello World\" in quotation marks? That is because \"Hello World\" is text, so we should put it in quotes and make it into a string in our code. Also, since the string \"Hello World\" can be treated like a value, we can also say it is an expression, and therefore we can use it in the expression part of the statement. This may seem pretty straightforward now, but as our programs become more complex it is important to think about what pieces of code can be treated as values, expressions, and statements.\nWhen we run that program in Python, we’ll see the following output:\nHello World If you look at the output, you might notice something strange - the text on our user interface doesn’t include the quotation marks \"\" that the expression \"Hello World\" contained. When we display text to the user, Python will remove the quotation marks from the beginning and the end of the string, and just display the text inside. Pretty handy!\nLet’s go through the full process of writing and running that program in Python!\nWriting a Python Program The first step to create a program in Python is to create a text file to store the code. This file should have the file extension .py to indicate that it is a Python program. So, we’ll need to create that file either on our computers or in Codio or another tool if we are using one. For example, in Codio we can create the file in the python folder by right-clicking on it and selecting the New File option. We’ll name the file hello.py:\nOnce we’ve created that file, we can then open it by clicking on it. In Codio and in other online tools, it will open in the built-in editor. On a computer, we’ll need to open it in a text editor specifically designed for programming. We recommend Visual Studio Code, which is available on all platforms. Tools like the built-in Notepad tool on Windows, or a word processor like Word or Pages do not work for this task.\nIn that file, we’ll simply place the code shown above, like this:\nThat’s all there is to it!\nRunning a Python Program Once we’ve written the code, we can open the Terminal and navigate to where the code is stored in order to run the program. On Codio, we’ll just use the cd python command to enter the python directory. On a computer, we’ll need to navigate the file system to find the location where we placed our code. We highly recommend creating a folder directly within the home directory and placing all of our code there - that will make it easy to find!\nOnce we are in the correct directory, we can use the ls command to see the contents of that directory. If we see our hello.py file, we are in the correct location:\nIf we don’t see our file, we should make sure we’ve saved it and that our current working directory is the same location as where the file is stored.\nFinally, we can execute the file in Python using the python3 command, followed by the name of the file:\npython3 hello.py If everything works correctly, we should see output similar to this:\nThere we go! We’ve just run our first program in Python! That’s a great first step to take.\nOf course, there are lots of ways that this could go wrong. So, if you run into any issues getting this to work, please take the time to contact an instructor and ask for assistance. This process can be daunting the first time, since there are so many things to learn and so many intricacies we simply don’t have time to cover up front. Don’t be afraid to ask for help!\n",
    "description": "",
    "tags": null,
    "title": "Print Statement",
    "uri": "/01-basic-python/03-print-statement/"
  },
  {
    "content": " Resources Slides Concatenate Python includes an operator that can be used to concatenate two strings together. We can use the plus symbol + between two strings to concatenate them together into a single string, making it much simpler to build more complex strings and outputs.\nA simple example is shown below:\nfirst = \"Hello\" second = \"World\" print(first + second) When executed, this code will display this output:\nHelloWorld As we can see, using the + operator in Python to concatenate two strings together is a quick and easy way to simplify our print statements.\nConcatenating Numbers Python also requires both sides of the + operator to be strings in order for concatenation to work. So, if we want to concatenate a string with a numeric value, we’ll have to convert it to a string using the special str() function. Here’s an example:\ntext = \"Your total is $\" value = 2.75 print(text + str(value)) When we run this program, we’ll receive the following output:\nYour total is $2.75 However, if we forget to convert the value variable to a string, as in this example:\ntext = \"Your total is $\" value = 2.75 print(text + value) we’ll receive an error instead:\nTraceback (most recent call last): File \"tutor.py\", line 3, in \u003cmodule\u003e print(text + value) TypeError: must be str, not float So, we’ll have to be careful and make sure that we convert all of our numbers to strings before trying to concatenate them together. Of course, if both sides of the + operator are numbers, then it will perform addition instead of concatenation!\nRepeat Python also includes an operator that allows us to quickly repeat strings. We can use the asterisk * operator to effectively “multiply” a string. Consider this example:\nword = \"repeat\" print(word * 2) print(word * 4) When we run this program, we’ll see the following output:\nrepeatrepeat repeatrepeatrepeatrepeat This allows us to build outputs that consist of repeated strings. We can also use this to quickly format our output into various shapes and structures!\nEscape Finally, we can also use the escape operator \\ to handle some certain special characters in Python strings. We’ve already seen this used in the newline character, which is simply the escape operator \\ followed by the letter n, as in \\n.\nHowever, we can also use it to include quotation marks in our string itself. Consider the following example:\nsentence = \"Hello from \"the little apple!\"\" print(sentence) When we try to run this code, we’ll get the following error:\nFile test.py, line 1 sentence = \"Hello from \"the little apple!\"\" ^ SyntaxError: invalid syntax This is because the double quotation mark \" is used to show which part of the code is a string value, but the Python interpreter gets confused when we try to include quotation marks inside of our strings. So, we can use the escape operator \\ to tell it to treat those quotation marks as part of the string value itself, and not part of the Python code:\nsentence = \"Hello from \\\"the little apple!\\\"\" print(sentence) This program will execute properly and produce the following output:\nHello from \"the little apple!\" Notice that the quotation marks now appear correctly in the output, but the escape operators are not shown. There are many other special ways to use the escape operator in Python, all of which can be found in the Python Documentation.\nSingle and Double Quotes Python also allows us to mix single and double quotes in a string, as long as we use them consistently, So, we can change the previous example to use single quotes around the string itself, and remove the escape operator from the double quotes, which will result in this code:\nsentence = 'Hello from \"the little apple!\"' print(sentence) This code will also produce the desired output. However, in this class we won’t use single quotes around strings, just for consistency. Many other programming languages don’t allow this, so we encourage you to learn how to use the escape operator to handle these situations.\n",
    "description": "",
    "tags": null,
    "title": "String Operators",
    "uri": "/03-strings-input/03-string-operators/"
  },
  {
    "content": " Resources Slides Determining Variable Type One thing that is very useful to know how to do in Python is determining the type of data stored in a variable. Python is very flexible, and we can store any type of data in any variable. In fact, a variable’s data type can even change in Python, which is something that many other programming languages won’t allow. Technically speaking, we would say that Python uses strong typing, which means that each variable has a known data type that we can find, and dynamic typing, meaning that the type of the variable can change while the program is running.\nTo determine the type of a variable, we can use the type(expression) function in Python. We can simply place any variable or expression in the expression argument, and then it will tell us the type of the value that results from evaluating that expression. Then, we can simply use the print() function to print it to the screen. We won’t use this in our programs themselves, but it can be helpful for debugging purposes or to just better understand what is going on with data types.\nHere’s a quick example program showing the type() function in Python:\nx = \"Hello\" y = 5 z = 6.7 print(type(x)) print(type(y)) print(type(z)) When we execute this code in Python, we should see the following output:\n\u003cclass 'str'\u003e \u003cclass 'int'\u003e \u003cclass 'float'\u003e Based on that output, we can assume that the variable x is the str data type for strings, y is the int data type for whole numbers, and z is the float data type for decimal numbers. The type() function is pretty handy!\nConverting Between Data Types We can also convert values between the various data types in Python. To do this, there are special functions that match the name of the data types themselves. So, to convert any value to a string, we can use the str() function. Likewise, to convert anything to an integer, we can use the int() function. And finally, to convert anything to a floating-point value, we can use the float() function.\nSo, we can extend the previous example a bit by showing how we can convert values between different data types:\nx = \"5.7\" print(x) print(type(x)) print() y = float(x) print(y) print(type(y)) print() z = int(y) print(z) print(type(z)) When we run this program, we’ll get this output:\n5.7 \u003cclass 'str'\u003e 5.7 \u003cclass 'float'\u003e 5 \u003cclass 'int'\u003e In this program, we’re starting with the string value \"5.7\" stored in variable x. So, the first two print() statements will print that string value, and show that x is indeed storing a str data type. Then, we’ll use the float() function to convert the string value \"5.7\" stored in x to the floating-point value $ 5.7 $ and store that in y. The next two print statements will print that value, and show that y is storing a float data type. Notice that the value printed for both variables x and y looks identical, but the data type of each variable is different!\nFinally, we can use the int() function to convert the floating-point value $ 5.7 $ to an integer. In math, when we are asked to convert the number $ 5.7 $ to a whole number, our first instinct is probably to just round up to $ 6 $, since that is the closest value. However, in Python, as in most other programming languages, this function will simply truncate the value instead. Truncating a value simply means we take off the end of the value, so to convert $ 5.7 $ to an integer we just remove the decimal portion, and we’re left with the value $ 5 $. So, in the output above, we see that z stores the integer value $ 5 $, and it is the int data type.\nNotice that we are careful to say that the int() function will truncate the value, and not that it will round down. This is due to how Python handles negative numbers like $ -5.7 $. When converting that to an integer, it will also truncate it to $ -5 $ instead of rounding down to $ -6 $. So, we use the word truncate as the best way to describe the int() function.\nExceptions Since we are running our Python programs on a real computer, we have to be a bit careful about how we use these functions. Specifically, if we try to convert a value to a different data type and Python can’t figure out how to do that, we’ll cause an exception to occur. An exception in programming is any error that happens when the computer tries to run our code.\nFor example, what if we try to convert the string value \"5.7\" directly to an int data type, as in this example:\na = \"5.7\" print(a) print(type(a)) print() b = int(a) print(b) print(type(b)) When we try to run this code in a file, such as the tutor.py file shown here, we’ll see this output printed on the terminal:\n5.7 \u003cclass 'str'\u003e Traceback (most recent call last): File \"tutor.py\", line 5, in \u003cmodule\u003e b = int(a) ValueError: invalid literal for int() with base 10: '5.7' Uh oh! That’s not good. In the output, we can see that we’ve caused a ValueError, which is an exception that happens when we try to use a value in an incorrect way. So, we’ll need to carefully look at our code to see if we can find and fix the error.\nThankfully, in the output, it will tell us that the error occurred on line 5 of the file tutor.py, so we can open that file and scroll to that line of code:\nb = int(a) This is where the error occurred. There are several ways we can fix it. The easiest would be to simply convert a to a floating-point value using the float() function instead.\nLearning how to find and fix these exceptions is a key part of learning how to program. We’ll inevitably run into a few exceptions as we start to build larger and more complex programs. In this course, most exceptions can be easily handled simply by working carefully through the code, but every once in a while we may run into an exception that is truly difficult to solve. That’s one of the important things to remember when learning how to program - it is sometimes much easier to cause an exception than it is to figure out how to fix it, and sometimes you may need to reach out for help to get past a particularly tricky exception. So, don’t be afraid to ask the instructors or TAs for help if you get stuck on an exception. Many times, it’s a great chance for you to learn some new programming skills.\n",
    "description": "",
    "tags": null,
    "title": "Types",
    "uri": "/02-numbers/03-types/"
  },
  {
    "content": " Resources Slides Now that we have the ability to store numerical data in variables in Python, we should also learn how to manipulate that data into something new. To do that, let’s learn about operators. An operator in programming is a special symbol that can be used in an expression to manipulate the data in some way.\nMost operators are binary operators, which means they perform an operation that uses two values as input and produces a single value as output. In fact, in some programming languages, the operators themselves are implemented as functions in the language! Finally, we have to be careful not to confuse these with bitwise operators, which are operators perform operations on the binary value stored in a variable. We won’t cover those operators in this class, but the terminology is a bit confusing.\nAn expression containing a binary operator typically follows this format:\n\u003cexpression\u003e \u003coperator\u003e \u003cexpression\u003e As before, the \u003cexpression\u003e parts can be any valid expression in the language that can be reduced to a single value, and the \u003coperator\u003e part is typically a single symbol, but it can also be a short keyword as well.\nThankfully, these operators should all be very familiar to us from mathematics already, so this is just a quick discussion of how they can be used in programming.\nAddition and Subtraction For starters, we can use the plus + and minus - symbols as operators to perform addition and subtraction in Python, just like in math. For example, we can add two variables together to create a third variable as shown in this example:\na = 5 b = 7 c = a + b print(c) When we run this code in the Python interpreter, we should get this result:\n12 Likewise, we can subtract two variables using the minus symbol - as shown here:\nx = 24 y = 10 z = x - y print(z) This code should produce this output:\n14 Multiplication and Division In Python, we use the asterisk *, sometimes referred to as the star symbol, to multiply two values together. For example, we can find the product of two values as shown in this Python block:\na = 6 b = 7 c = a * b print(c) When we run this code, we should see the following result displayed to the user:\n42 Division is performed using the slash / symbol. A great way to think of division in programming is just like a fraction, since it uses the same symbol between the two numbers. For example, if we execute this code:\nx = 27 y = 3 z = x / y print(z) we would see this output:\n9.0 What if the division would result in a remainder? In that case, we’ll simply use decimal values in Python so that the result is exactly correct. For example, if we try to divide $ 19 $ by $ 5 $, as in this example:\na = 19 b = 5 c = a / b print(c) When we run this code, the Python interpreter will produce the following output:\n3.8 So, as we can see, all of these operators in Python work exactly like their counterparts in math. So, we can easily use them in a way that should be very familiar to us.\n",
    "description": "",
    "tags": null,
    "title": "Basic Operators",
    "uri": "/02-numbers/04-basic-operators/"
  },
  {
    "content": " Resources Slides Python also uses various comparators to allow us to compare values of many different data types to produce a Boolean value. We can compare numbers, strings, and many other data types in Python using these comparators.\nThe basic comparators in Python are:\n== equal != not equal \u003c less than \u003c= less than or equal to \u003e greater than \u003e= greater than or equal to Notice that the equal comparator in Python now uses two equals signs == instead of a single one. This is because the single equals sign = is used in the assignment statement, and we don’t want to confuse a Boolean comparator for an assignment. So, in Python, as in most other programming languages, we use two equals signs == when comparing values, and one equals sign = when we are storing a value in a variable.\nComparing values Just like in pseudocode, we usually only want to compare values of the same data type using comparators. It really only makes sense to compare strings to strings, and Booleans to Booleans. However, for the numeric data types int and float, we can easily compare values of either data type together in Python.\nConsider the following example:\nx = 5 y = 5.0 print(x == y) When we execute this code, we’ll get this output:\nTrue Even though x is the int data type and y is the float data type, they both store the same numerical value, and our comparators will work just like we expect. So, we can easily compare both integers and floating-point values in our code.\nCoercion Behind the scenes, when we compare an int and a float value in Python, Python will convert the values to a common data type, usually the float data type, using the appropriate conversion function. This is known as coercion in programming - the program is essentially forcing a value of one data type into another data type because of an operation. However, it won’t change the data type of the variable involved, just the value it is evaluating.\nStrings in Python can also be compared using the various comparator operators. When two strings are compared using any type of “less than” or “greater than” comparator, they will be compared according to their lexicographic order. In general, this means that each letter will be ordered based on its value in the ASCII encoding standard.\nLet’s look at a quick example:\na = \"First\" b = \"fir\" print(a \u003c b) When we run this code, we’ll see this output:\nTrue This may seem surprising, since we’d expect the word \"fir\" to come before the word \"First\" in a dictionary, since it has fewer letters. However, in Python, the letters \"f\" and \"F\" are not treated identically. According to the ASCII encoding standard, capital letters have a lower value than lower-case letters, so all words starting with a capital \"F\" will come before any words starting with a lower-case \"f\".\nThis can be a bit confusing, so it is always important to remember that we can always write a quick sample program in Python to test how a particular operator will work for a given set of values. If nothing else, we can always count on our computer to produce the same result for the same operation, no matter if it is part of a larger program or a small test program.\nOrder of Operations Finally, Python’s order of operations can be updated to include these Boolean comparators and operators. So, when we see an expression that combines mathematical operators with Boolean operators and comparators, we’ll follow this order:\nMath operators (according to their order of operations) Boolean comparators not operator and operator or operator As always, it is considered good practice to include parentheses in any complex expressions to make sure that the intent is clear, regardless of the order of operations.\n",
    "description": "",
    "tags": null,
    "title": "Boolean Comparators",
    "uri": "/04-conditionals/04-comparators/"
  },
  {
    "content": " Resources Slides Python also includes another method of building strings, which are known as “F-strings”. F-strings allow us to put placeholders in strings that are later replaced with values from variables, effectively creating a way to build “templates” that can be used throughout our program.\nThe easiest way to see how this works is looking at a few examples. Let’s start with a simple one:\nname = input(\"Enter your name: \") print(f\"Hello {name}\") If the user inputs \"Willie Wildcat\" when prompted, then this code will produce this output:\nEnter your name: Willie Wildcat Hello Willie Wildcat There are many important parts to this example, so let’s look at each one individually. First, in the print() statement, we see the string \"Hello {name}\". This is an example of a template string, which includes a set of curly braces {} as placeholders for data to be inserted. Each template string can have unlimited sets of curly braces. Inside of each set of curly braces, we can place the variable or expression that will be printed at that location.\nAlso, we notice that in front of the string, we see the character f. Preceding a string with f outside of the quotation marks will denote the string as an f-string (hence the name), which allows the values inside to be interpolated. Interpolation is the term used when formatting marks in a string, such as the curly braces in an f-string, are interpreted and replaced with the correct values they represent.\nAdvanced Formatting Python f-strings can do many powerful things, such as handle more complex formatting and multiple lines. For right now, we’ll just use simple variable placeholders in our f-strings, but over time we’ll introduce additional ways to use f-strings to achieve the desired output.\nThe most powerful use of f-strings is to insert numerical values directly into strings without having to convert each value directly to the str data type - the interpolation process handles this for us.\nFor example, we can update our previous program to use f-strings to display the output in a single print() statement, and we can also add additional information with ease:\ntext_one = input(\"Enter the price of one item: \") price = float(text_one) text_two = input(\"Enter the quantity of items: \") quantity = int(text_two) cost = price * quantity print(f\"{quantity} items at ${price} each is ${cost} total\") When we execute this program, we’ll see output that looks like this:\nEnter the price of one item: 2.75 Enter the quantity of items: 3 3 items at $2.75 each is $8.25 total This example shows how easy it is to build complex output strings using f-strings.\nFormat Method Prior to the introduction of f-strings, it was common to use the format() method to place values inside of a template string. The last line of the previous example would look like this using the format method:\nprint(\"{} items at ${} each is ${} total\".format(quantity, price, cost)) As we can see, the format() method receives each value as an argument, and it will replace the curly brace placeholders {} in the template string with each value, working from left to right. The output produced will be identical to the f-string in the example above.\nWe won’t use the format() method in this class, but you may see it in many online tutorials and documentation since f-strings were introduced relatively recently.\n",
    "description": "",
    "tags": null,
    "title": "F-Strings",
    "uri": "/03-strings-input/04-f-strings/"
  },
  {
    "content": " Resources Slides Loops in Python are also a great way to handle situations where a user must input a value that meets certain criteria. Previously, we used an if statement to determine if the input was valid, but if it wasn’t valid all we could do was print an error and end the program. If we use a loop instead, we can prompt the user to provide additional input until we receive a valid value.\nTo make this process easy to use, we can develop a block of code just to handle input from the user. For example, if we want the user to input a percentage, we could use code similar to this:\nx = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) This code starts by prompting the user to input a number, and stores it as a floating-point value in the variable x. Then, it will reach the start of the while loop. The Boolean expression will check to see if the value provided is not a percentage, so if it is less than $ 0 $ or greater than $ 1 $ it is considered invalid.\nIf the input is invalid, we’ll print an error and prompt the user for input again. We’ll keep repeating this process until the user provides a value between $ 0 $ and $ 1 $, at which point the loop will terminate. At this point, we know that the value stored in x is a valid value.\nReading Input With code such as that in our program, we can use it to actually read input directly from the user. For example, we can write a quick program to calculate a weighted average of exam scores as shown below:\nprint(\"This program will compute weighted average for three exam scores\") print(\"Enter the first exam's score\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) exam1_score = x print(\"Enter the first exam's weight\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) exam1_weight = x print(\"Enter the second exam's score\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) exam2_score = x print(\"Enter the second exam's weight\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) exam2_weight = x print(\"Enter the third exam's score\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) exam3_score = x print(\"Enter the third exam's weight\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) exam3_weight = x total = exam1_score * exam1_weight + exam2_score * exam2_weight + exam3_score * exam3_weight print(\"Your total score is {}\".format(total)) A quick execution of this program is shown here:\nTake a minute to confirm that the program works by running it yourself, either in Python Tutor or directly in Python. You can even adapt this program to help calculate your final grade in this course!\nLearning to how to create building blocks of larger programs, such as loop for checking input described here, is a great way to develop our programming skills. If we can learn to take a large program and break it down into smaller, repeatable chunks, then the entire program becomes much easier to develop and maintain.\nRepeated Code Are you starting to ask yourself if there is a better way to handle repeated blocks of code like this? If so, that’s great! We’ll cover functions, which is a way to build repeatable pieces of code that can be used throughout our programs, in the next chapter!\n",
    "description": "",
    "tags": null,
    "title": "Input with Loops",
    "uri": "/05-loops/04-input-loops/"
  },
  {
    "content": " Resources Slides One important key to remember: by default, the print(expression) statement in Python will add a newline to the end of the output by default. This means that multiple print(expression) statements will print on multiple lines. Let’s look at some examples!\nThroughout this course, we’ll show many different code examples and their output here in the lab. To test them out, feel free to copy the code examples to a Python file and run it yourself. You can even tweak them to do something new and see how Python interprets different pieces of code. In the end, the best way to learn programming is to explore, and running these examples on your own is a great way to get started!\nExample 1 - Multiple Statements First, let’s write a simple program that prints 4 letters separated by spaces:\nprint(\"a b c d\") Just like our “Hello World” program, when we run this program, we’ll see that string printed in the user interface:\na b c d Ok, that makes sense based on what we’ve previously seen. The print(expression) statement will simply display any string expression in our user interface.\nOf course, programs can consist of multiple statements or lines of code. So, what if we write a program that contains multiple print(expression) statements, like this one:\nprint(\"one\") print(\"two\") print(\"three\") print(\"four\") What do you think will happen when we try to execute this program on our “mental model?” Have we learned a rule that tells us what should happen yet? Recall on the previous page we learned that it will print the value on the user interface, but that’s it. So, when we execute this program, we’ll see the following output:\none two three four That’s a very interesting result! We can see that four separate print(expression) statements will generate four lines of output by default. Each statement is printed on its own line. So, in Python we can print multiple lines of output simply by using multiple print(expression) statements!\nExample 2 - Multiple Lines from Single Statement What if we want to print output on multiple lines using a single print(expression) statement? How can we do that? In this case, we need to introduce a special symbol, the newline symbol. In most programming languages, the newline symbol is represented by a backslash followed by the letter “n”, like \\n, in a string. When our user interface sees a newline symbol, it will move to the next line before printing the rest of the string. The newline symbol itself won’t appear in our output.\nFor example, we can update our previous program to contain newline symbols between each letter:\nprint(\"a\\nb\\nc\\nd\") This might be a bit difficult to read at first, but as we become more and more familiar with reading code, we’ll start to see special symbols like the newline symbol just like any other letter. For now, we’ll just have to read closely and make sure we are on the lookout for special symbols in our text.\nWhen we run this program, we should see the following output on our user interface:\na b c d There we go! We’ve now figured out how to print text on multiple lines using a single print(expression) statement.\nExample 3 - Multiple Statements on Same Line What if we want to display multiple print(expression) statements on the same line? To do that, we must add an additional option to the print(expression) statement - the end option.\nFor example, the following code will produce output all on the same line:\nprint(\"Hello \", end=\"\") print(\"World!\") In this example, we set end to be an empty string \"\". When we run this program, we’ll get the following output:\nHello World! In fact, in Python, the print(expression) statement is an example of a function in Python. Functions are just repeatable procedures in our code - when we use them, we write the name of the function, followed by a set of parentheses and then inputs, or “arguments,” separated by commas within the parentheses. This is known as “calling” a function. So, in actuality, the expression in the print(expression) statement is just the first argument when we call the print function.\nTherefore, the end option that we showed above is just a second argument that is optional - it simply lets us choose what to put at the end of the output. By default, the end parameter is set to the newline symbol \\n, so if we don’t provide an argument for end it will just add a newline at the end of the value.\nWe can set the value of end to be any string. If we want to include a space at the end of the output, we can add end=\" \" to the print function call.\nIn this course, we won’t spend much time talking about optional parameters and default values in Python functions, but it is important to understand that statements like print are actually just Python functions behind the scenes!\n",
    "description": "",
    "tags": null,
    "title": "Using Print",
    "uri": "/01-basic-python/04-using-print/"
  },
  {
    "content": "Let’s try some simple practice problems. These problems are not graded - they are just for you to practice before doing the real exercises in the lab itself. You can find the answers below each question by clicking the button below each question.\n4.1 Reading Code What is printed to the terminal when the following Python program is run?\na = 5 b = 10 c = 15 x = b \u003e a and c \u003c b or (not (a + b \u003e c)) y = b + a \u003e= c or c / a \u003e b / a z = c - b != a and not c % a == 0 print(x) print(y) print(z) Try to work out the solution yourself first before running the code.\nAnswer 4.1 Answer The correct answer is:\nTrue True False 4.2 Reading Code What is printed to the terminal when the following Python program is run?\nx = 7 y = 42 z = 6 a = x \u003e= z and y \u003c= x * z or not y % z == 0 b = not (y // x \u003c= z or x - z \u003e 0 or y % x != 1) c = y // (z + x) \u003c z / 2 and not bool(z) print(a) print(b) print(c) Try to work out the solution yourself first before running the code.\nAnswer 4.2 Answer The correct answer is:\nTrue False False 4.3 Writing Code Write a Python program that performs the following operations:\nPrompts the user for four integer inputs and stores them in variables If the first input is strictly smaller than all other inputs, and the last input is strictly larger than all other inputs, print True. If not, print False. Your program may not use any conditional statements (if statements).\nHint: what comparisons must be made, and what comparisons do not need to be made, to answer these questions definitively?\nAnswer 4.3 Answer One possible answer is given below:\na = int(input(\"Enter an integer: \")) b = int(input(\"Enter an integer: \")) c = int(input(\"Enter an integer: \")) d = int(input(\"Enter an integer: \")) x = a \u003c b and a \u003c c and a \u003c d and b \u003c d and c \u003c d print(x) Notice that a is compared with the other three variables directly, as is d. The comparison between a and d is only included once.\n4.4 Writing Code Write a complete program in Python that performs the following operations:\nPrompts the user for three integer inputs and stores them in variables. If the second and third inputs are multiples of the first, and the third input is a multiple of the second, print true. If not, print false. Your program may not use any conditional statements (if statements).\nHint: you can use the modulo % operator to determine if one number is evenly divisible by another number. Can this also tell you which number is a multiple of another number?\nAnswer 4.4 Answer One possible solution is given below:\nx = int(input(\"Enter an integer: \")) y = int(input(\"Enter an integer: \")) z = int(input(\"Enter an integer: \")) a = y \u0026 x == 0 and z % y == 0 print(a) Notice that it only checks if y % x and z % y are equal to 0. If those are both true, then z % x is implied to be true.\n",
    "description": "",
    "tags": null,
    "title": "Boolean Practice",
    "uri": "/04-conditionals/05-boolean-practice/"
  },
  {
    "content": " Resources Slides Finally, let’s look at how we can rewrite some of our previous Python programs by combining expressions into more complex statements. Python allows us to perform multiple actions on a single line of code, provided they can all be combined in some way to create a single statement.\nLet’s consider the example on the previous page, shown here:\ntext_one = input(\"Enter the first number: \") one = int(text_one) text_two = input(\"Enter the second number: \") two = int(text_two) one = one * one two = two * two total = one + two print(f\"The sum of squares of {one} and {two} is {total}\") There are many ways we can write this program to perform the same work. For example, the process of computing the sum of squares itself can actually be reduced to a single line of code as seen below:\ntotal = (one * one) + (two * two) We can perform multiple mathematical operations in a single expression, and as long as we either use parentheses or pay attention to the order of operations, we’ll get the expected answer. We don’t have to store the intermediate values in variables, since Python will do that for us when it evaluates the expression.\nLikewise, we can put the input() function inside of the int() function, allowing us to read input as a string and convert it to an integer in a single line:\none = int(input(\"Enter the first number: \")) two = int(input(\"Enter the second number: \")) total = (one * one) + (two * two) print(f\"The sum of squares of {one} and {two} is {total}\") Finally, we can also move the computation of the sum of squares directly into the f-string. When Python tries to print the f-string, the interpolation process must compute that value before it can print the output.\none = int(input(\"Enter the first number: \")) two = int(input(\"Enter the second number: \")) print(f\"The sum of squares of {one} and {two} is {(one * one) + (two * two)}\") Functionally, this code will create the exact same output as the previous code, but it will do so using fewer variables and statements. Each statement is simply more complex, consisting of multiple expressions.\nConcise and Readable The real question is: which of these two examples is best? That is, which one is the preferred coding style to learn? The answer is that it really depends - both have their merits, and functionally they will work nearly identically on most modern computers and programming languages.\nIt really is a question of style - is it better to have more lines of code and variables, clearly spelling out what each step of the process is, or is it better to have shorter programs with more complex lines of code but maybe fewer variables? For beginning programmers, it is usually recommended to follow the first style, using as many variables as needed and focusing on short, concise lines of code over large, complex statements.\nHowever, as we become more accustomed to programming, we’ll find that many times it is easier to read and understand complex statements, and our code can be written in a way that better reflects what it is actually doing.\nThis is very similar to learning how to read, write, and speak in a new language. We must start with short, concise sentences, and slowly build up our knowledge of more complex statements and grammar rules until we become a fluent speaker.\nOverall, the best advice to follow is to make your code readable to both yourself and anyone else who may have to read and maintain the code. As long as it is clear what the code is doing based on what it says, it is probably a good style to follow. As we continue to learn more, we’ll slowly refine our coding style to be one that is easy to follow and understand for everyone.\n",
    "description": "",
    "tags": null,
    "title": "Complex Statements",
    "uri": "/03-strings-input/05-complex-statements/"
  },
  {
    "content": " Resources Slides Modulo Operator The Python programming language also includes a few math operators that are not commonly used outside of programming.\nThe first one is the modulo operator. The modulo operator is used to find the remainder of a division operation. If we think back to math again, we’ve probably learned how to perform long division when dividing two values. At the end, we might be left with a remainder, or a portion of the first number that is left over after the operation is complete. In many computer programs, that value is very useful, so we have a special operator we can use to find that value. In Python, we use the percent symbol % as the modulo operator.\nFor example, if we want to find the remainder after dividing $ 19 $ by $ 5 $, we would use the following code:\nx = 19 y = 5 z = x % y print(z) When we run this code, we would get the following output:\n4 This is because the value $ 5 $ will fit into the value $ 19 $ only $ 3 $ times, and then we’ll have the value $ 4 $ left over. Mathematically, we are saying that $ 19 / 5 = (3 * 5) + 4 $. Since $ 4 $ is the leftover portion, it is the resulting value when we use the modulo operator.\nIn this course, we’ll only worry about how the modulo operator works when applied to positive whole numbers. In practice, it can be applied to any numerical value, including decimal values and negative numbers, but those values are not really useful in most cases. So, to keep things simple, we’ll only use positive whole numbers with this operator.\nExponentiation Operator The next operator introduced by Python is the exponentiation operator. The double star ** operator is used to represent exponentiation, sometimes referred to the power operator. In Python, the expression 2 ** 3 would be written mathematically as $ 2^3 $, which is the operation of taking $ 2 $ to the power of $ 3 $, or multiplying $ 2 $ by itself $ 3 $ times.\nHere’s a quick example of using the ** operator in code:\nx = 5 ** 3 print(x) print(type(x)) When this code is run, we see the following output:\n125 \u003cclass 'int'\u003e ||| growthhack\nDon’t Use the Carat ^! Many other programming languages and tools use the carat ^ character to represent the exponentiation operation. However, in Python, the carat ^ character is used to represent the bitwise XOR operation. So, we must be careful not to accidentally use the ^ operator when we actually mean to use the ** operator for exponentiation.\n|||\nInteger Division Operator Finally, Python also includes the integer division operator, represented by two forward slashes //, which is used to perform division that truncates the result to an integer. However, as we’ll see on the next page, if either of the values in the operation is a float value, it will return a value that is a float data type, even though the result is an integer value.\nLet’s look at an example with that operator in code:\na = 17.5 // 4.5 print(a) print(type(a)) As we expect, when we run this program, we’ll get the following output:\n3.0 \u003cclass 'float'\u003e So, we see that this operator will return a float value, even though it is truncating the result to an integer, simply because the input values contained a float.\n",
    "description": "",
    "tags": null,
    "title": "New Operators",
    "uri": "/02-numbers/05-new-operators/"
  },
  {
    "content": "Let’s try some simple practice problems. These problems are not graded - they are just for you to practice before doing the real exercises in the lab itself. You can find the answers below each question by clicking the button below each question.\n1.1 Reading Code What is the output that is displayed to the user after running the following Python code:\nprint(\"Kansas State University\") print(\"Manhattan \", end=\"\") print(\"KS\", end=\" \") print(\"66506\") print(\"KSU!\\nGo Cats!\") Answer 1.1 Answer The correct output:\nKansas State University Manhattan KS 66506 KSU! Go Cats! 1.2 Constructing Code We want to write a program that produces the following output:\n* * * * * * Rearrange the following Python statements to create a program that produces that output. You may not use all of these statements in your answer.\nprint(\"*\") print(\"*\") print(\"*\") print(\"*\", end=\" \") print(\"*\", end=\" \") print(\"*\", end=\" \") Answer 1.2 Answer One solution:\nprint(\"*\") print(\"*\", end=\" \") print(\"*\") print(\"*\", end=\" \") print(\"*\", end=\" \") print(\"*\") 1.3 Writing Code Write a Python program that will display the last five letters of the alphabet, one per line.\nAnswer 1.3 Answer One possible answer is shown below:\nprint(\"v\") print(\"w\") print(\"x\") print(\"y\") print(\"z\") Many others are possible!\n",
    "description": "",
    "tags": null,
    "title": "Print Practice",
    "uri": "/01-basic-python/05-print-practice/"
  },
  {
    "content": " Resources Slides Another important aspect of working with loops in code is learning how to properly test programs that contain loops. So, let’s look at some of the methods we can use when testing our programs containing loops to make sure they work correctly and won’t run into any problems.\nBranch and Path Coverage Loops, like conditional statements, introduce different branches and paths into our programs. So, one of the first steps when testing these programs is to develop a set of inputs that will execute each branch of the code, as well as finding inputs that will execute multiple different paths through the program. Since loops may repeat many times, typically we only worry about two possible paths when dealing with loops - one path where it is skipped entirely and another path where the loop is entered at least once.\nLet’s consider this simple Python program that contains loops:\nx = int(input(\"Enter a number: \")) y = int(input(\"Enter a number: \")) i = 0 line = \"\" while i \u003c x + y: line = line + \"*\" print(line) i = i + 1 while i \u003e x - y: print(\"=\", end=\"\") i = i - 1 print() This program will simply print a right triangle of asterisks * that is x + y characters wide and tall, similar to a previous example in this lab. However, it will also print a final line of equals signs = below that, consisting of x - y characters. To test this program, we want to try and find some input values for x and y that achieve branch and path coverage.\nBranch Coverage To achieve branch coverage, we want to execute each line of code in this program at least once. An easy way to do that is to provide inputs so that the sum of x and y is a positive number in order to enter the first loop. After the first loop terminates, the value of i will be equal to the sum of x and y, provided that value is greater than $ 0 $. So, in order to also enter the second loop, we need to make sure the difference of x and y is smaller than their sum.\nA set of inputs that achieves this would be $ 3 $ and $ 1 $ for x and y, respectively. Their sum is $ 4 $, so the first loop will be executed 4 times. Then, the difference between the values is $ 2 $, so the second loop will executed twice to reduce the value in i to $ 2 $.\nSo, we can say that the inputs 3 and 1 are enough to achieve branch coverage.\nPath Coverage To achieve path coverage, we must consider three additional paths through the program:\nNeither loop is entered Only the first loop is entered Only the second loop is entered First, in order to enter neither loop, we must have a set of inputs where the sum is less than or equal to $ 0 $, and also where the difference is less than or equal to $ 0 $. The simplest way to achieve this is to set both inputs to exactly $ 0 $! Sometimes the simplest inputs are the easiest for testing.\nTo enter the first loop only, we need the situation where the sum of x and y is greater than 0, but then their difference is even larger. An easy way to accomplish this is to set y to a small negative number. For example, we could set x to $ 3 $ and y to $ -1 $. That will make their sum $ 2 $ but the difference $ 4 $, so we’ll only execute the first loop but not the second one.\nFinally, if we want to execute the second loop only, we need to make both the sum and the difference of x and y a number less than $ 0 $. In that case, we can simply set both x and y to negative values, but make sure that x is overall a smaller value than y. So, we could set x to $ -3 $ and y to $ -1 $. In that case, their sum is $ -4 $ but their difference is $ -2 $. That will cause the program to skip the first loop but enter the second loop.\nSo, we can achieve path coverage with these four sets of inputs:\n3, 1 0, 0 3, -1 -3, -1 Loop Termination When testing loops, we should also check to make sure that the loops will eventually terminate if we ever enter them. Thankfully, in this program, it is very easy to reason about this and convince ourselves that it works.\nConsider the first loop - the only way to enter that loop is if the value of i is less than the sum of x and y, and each time the loop iterates the value in i will be incremented by $ 1 $. Since i is getting larger each time, eventually it will reach a value that is greater than or equal to x + y and the loop will terminate.\nThe same argument can be made for the second loop. In that loop, i is initially greater than the difference of x and y, but i is decremented each time, so eventually the loop will terminate.\nTechnically speaking, we can come up with a loop variant for each loop and show that it is monotonically decreasing. This is easily done by simply finding the difference between the iterator variable i and the termination condition of the loop, either the sum or the difference of x and y. We won’t ask you to get to this level of detail when testing your own loops, but it is a very useful concept to understand when working with loops.\nThere we go! We were able to quickly come up with a set of inputs that will execute all possible branches and paths in this program, and we can also show that each of the loops will properly terminate anytime they are executed. So, we know that our program at least won’t crash, no matter what integers are provided as input. We can also examine the output of each test and make sure that it matches what the expected output should be in order to show that our program not only doesn’t crash, but that it provides the correct output.\n",
    "description": "",
    "tags": null,
    "title": "Testing Loops",
    "uri": "/05-loops/05-testing-loops/"
  },
  {
    "content": " Resources Slides Now that we understand how to use Boolean values in our programs, it’s time to put those values to use. One way to think of the result of a Boolean expression is that it helps us make a decision in our programs. For example, if we want to do something special in our program when the user inputs the value $ 42 $ into the variable x, then we can write the Boolean expression x == 42 to help us decide if the user input the correct value.\nOnce we have that decision made, we need some way to tell our program to run a different piece of code based on the outcome of that decision. In Python, as well as most other programming languages, we can use a special construct called an if statement to do this. If statements are one example of a conditional statement in programming.\nThese conditional statements allow us to affect the control flow of our programs. Effectively, we can use a Boolean expression to determine whether a particular piece of code should be executed or not. In an if statement, we include a Boolean expression and a block of statements. If the Boolean expression evaluates to True, then we execute the code in the block of statements. If it is False, then we skip the block and continue with the rest of the program.\nThe structure of an if statement in Python is shown below:\nif \u003cboolean expression\u003e: \u003cblock of statements\u003e In this structure, we have a \u003cboolean expression\u003e that is evaluated. After the Boolean expression is a colon :, just like at the end of a function definition.\nThen, the \u003cblock of statements\u003e is included below the if statement’s first line, and it must be indented one level. Again, this is very similar to the structure of a function definition in Python. In Python, the \u003cblock of statements\u003e must include at least one line of code, otherwise Python won’t be able to understand it.\nLet’s go through a couple of code tracing examples in Python Tutor to see how an if statement works in code.\nCode Tracing Example - False Consider this program in Python:\nx = int(input(\"Enter a number: \")) if x == 7: print(\"That's a lucky number!\") print(\"Thanks for playing!\") We can see this example by clicking on this Python Tutor link. At first, our window should look something like this:\nWhen we step through the program, the first line of code will ask the user to input a number, so Python Tutor will show an input box at the bottom of the window:\nFor this first time through the program, let’s assume the user inputs the string \"42\" as input:\nSo, when we click Submit, we’ll see the integer value $ 42 $ stored in the variable x in the Global frame:\nAt this point, we’ve reached the if statement. The first step is to evaluate the Boolean expression x == 7. Since x is actually storing the value $ 42 $, this statement will evaluate to False. So, when we click the Next button on the state below:\nWe’ll see that the program arrow jumps past the block of statements in the if statement. So, the next line will simply print the goodbye message:\nThe entire process is shown in the animation below:\nAs we can see, when the Boolean expression evaluates to False, we’ll just skip the block of statements inside of the if statement.\nCode Tracing Example - True Now let’s see what happens when the Boolean expression evaluates to True instead. To see that, we can go back to the point where our program is asking for input, as shown below:\nThis time, we’ll assume the user inputs the string \"7\" as input.\nSo, when we click Submit, we’ll see the integer value $ 7 $ stored in the variable x in the Global frame:\nThis time, when we reach the if statement, we’ll see that the Boolean expression x == 7 will evaluate to True. So, when we click the Next button, we’ll be taken to the block of statements inside of the if statement:\nHere, we’ll print the special message for finding a lucky number:\nThen, we’ll print the program’s goodbye message:\nThe entire process can be seen in this animation:\nSo, when the Boolean expression evaluates to True, we’ll run the code inside the if statement. If it is False, then we’ll just skip past the if statement and continue with the rest of our program.\nIf Statement Flowchart Another way to visualize an if statement is using a flowchart. Consider the following Python code:\nx = int(input(\"Input: \")) if x \u003e 0: print(x) print(\"Goodbye\") This Python code can also be represented as the flowchart shown below:\nWhen we read flowcharts like this, we typically go from top to bottom, starting with the circle labeled “START”. The first step is to read input from the user, and store that value in the variable x.\nThen, we reach a decision node, which uses a diamond shape. This node asks if the value in the variable x is greater than 0. Notice that there are two lines coming from the decision node: one labeled “True” and another labeled “False”. They correspond to the possible values that can result from evaluating the Boolean expression x \u003e 0. So, if the result of that expression is True, then we’ll follow the path that exits the diamond from the side labeled “True”, and we’ll output the value x to the terminal. Once that is done, we can follow that path around to the next box that will output the string \"Goodbye\".\nIf that result is False, then we’ll follow the downward path labeled “False” and skip the path to the side. Instead, we’ll just reach the line that prints \"Goodbye\" and then end the program.\nAs we learn how to use if statements in our code, we might find it easier to use flowcharts or other tools to help understand exactly what our program will do. The path that a program takes through a flowchart like this is called the control flow of the program. We’ll discuss that topic a bit more toward the end of this lab.\n",
    "description": "",
    "tags": null,
    "title": "If",
    "uri": "/04-conditionals/06-if/"
  },
  {
    "content": "Let’s try some simple practice problems. These problems are not graded - they are just for you to practice before doing the real exercises in the lab itself. You can find the answers below each question by clicking the button below each question.\n3.1 Reading Code Write the output that is displayed to the user after running the following Python code:\nx = input(\"Enter a number: \") y = x + \"00\" z = int(y) a = int(z + (z / 100)) print(f\"The result is {a}\") Assume the user inputs the string \"4\" when prompted.\nAnswer 3.1 Answer The correct answer is:\nThe result is 404 3.2 Reading Code Write the output that is displayed to the user after running the following Python code:\nx = int(input(\"Enter a number: \")) x = x // 100 * 100 + x % 10 print(f\"The answer twice is {x * 2}\") Assume the user inputs the string \"121\" when prompted.\nAnswer 3.2 Answer The correct answer is:\nThe answer twice is 202 Notice that the x * 2 expression results in the value 202 instead of the string \"101101\". This is because x is an integer value, not a string. So, the * operator is interpreted as multiplication, not string repetition. We have to carefully keep track of what data type each variable is storing in order to truly understand what the code will do.\n3.3 Writing Code Write a Python program that prompts the user to input a verb and a noun that will be stored in separate variables. Then, use those two words to create a simple compliment for the user and print it to the terminal. The compliment should be in the form of:\nYou \"\u003cverb\u003e\" my \"\u003cnoun\u003e\"? That's awesome! For example, if the user inputs \"love\" and \"food\", then the string printed by the program should be:\nYou \"love\" my \"food\"? That's awesome! Hint: Notice that the output includes quotation marks around the two words provided by the user, and an apostrophe (single quote) as well. You’ll need to account for this in your code!\nYou can expand on this program to prompt the user for additional inputs, and use f-strings to create a Mad Libs style game!\nAnswer 3.3 Answer One possible answer is:\nverb = input(\"Enter a verb: \") noun = input(\"Enter a noun: \") print(f\"You \\\"{verb}\\\" my \\\"{noun}\\\"? That's awesome!\") The biggest point to remember is that quotation marks need to be escaped. If you try to use single quotes instead of double quotes around the f-string, you’ll need to escape the apostrophe (single quote) instead.\n",
    "description": "",
    "tags": null,
    "title": "Input Practice",
    "uri": "/03-strings-input/06-input-practice/"
  },
  {
    "content": " Resources Slides Since Python has multiple numeric data types, there are some rules that govern which data type is produced as a result of various math operations. Thankfully, the rules themselves are pretty straightforward once they are explained.\nResulting Data Types - Same Type The basic rule to remember, if a mathematical operator is applied to two variables of the same data type, the result will also be that data type.\nLet’s see what that means in practice. Here’s a quick example in Python using the multiplication operator on two integer values:\nx = 5 y = 10 z = x * y print(z) print(type(z)) When we run this code, we should see the following output:\n50 \u003cclass 'int'\u003e Since both x and y are the int data type, the result of x * y will also be an int value, so the variable z will have that data type, as shown in this example.\nHowever, there is one exception to this rule, which is the division operator /. In Python, the division operator will always return a float value, even if it is a whole number. Here’s an example that demonstrates that:\na = 9 b = 3 c = 4 x = a / b print(x) print(type(x)) print() y = a / c print(y) print(type(y)) When we run this program, we’ll see the following output:\n3.0 \u003cclass 'float'\u003e 2.25 \u003cclass 'float'\u003e So, as we can see, even though we are dividing two int values, we’ll get a float value as a result each time we use the division operator.\nFollowing the rule above, if we perform a mathematical operation between two float values, the resulting value will always be a float as well:\na = 2.5 b = 4.5 c = a + b print(c) print(type(c)) Running this code will produce this output:\n7.0 \u003cclass 'float'\u003e So, even though the result is a whole number, the value that is stored is the float data type.\nResulting Data Types - Different Type The other rule to remember is anytime an operation involves a float value and an int value, the result will be a float. So, if there are mixed types, Python will default to the float data type.\nThis can be seen in the following example:\na = 5 b = 2.0 c = a - b print(c) print(type(c)) When this code is executed, the output should look like this:\n3.0 \u003cclass 'float'\u003e Once again, even though the result is a whole number, because the variable b is a float value, the entire result will also be a float value.\nLearning the data types that are returned by a mathematical operator can be tricky, but most programmers slowly develop an intuition of how each operator works and what to expect. So, don’t worry too much if this is confusing right now, since it will become much clearer with practice! Also, don’t forget that we can always create a simple test program like the examples shown above to confirm the result for any operation.\n",
    "description": "",
    "tags": null,
    "title": "Resulting Types",
    "uri": "/02-numbers/06-resulting-types/"
  },
  {
    "content": " Resources Slides Now that we’ve learned how to use the print(expression) statement, let’s focus on the next major concept in Python, as well as any other programming language: variables.\nThe word variable is traditionally defined as a value that can change. We’ve seen variables like $x$ used in Algebraic equations like $x + 4 = 7$ to represent unknown values that we can try to work out. In programming a variable is defined as a way to store a value in a computer’s memory so we can retrieve it later. One common way to think of variables is like a box in the real world. We can put something in the box, representing our value. Likewise, we can write a name on the side of the box, corresponding to our variable’s name. When we want to use the variable, we can get the value that it currently stores, and even change it to a different value. It’s a pretty handy mental metaphor to keep in mind!\nIn a later lab, we’ll learn how to use operators to manipulate the values stored in variables, but for right now we’re just going to focus on storing and retrieving data using variables.\nCreating Variables To use a variable, we must first create one. In Python, we create a variable in a special type of statement called an assignment statement. The basic structure for an assignment statement is a = expression. When our Python interpreter runs this statement, it will first evaluate expression into a single value. Then, it will store that value in the variable named a.\nFor example, let’s consider the Python statement:\nx = \"Hello World\" In that statement, we are storing the string value \"Hello World\" in the variable named x. Pretty handy!\nNow, let’s cover some important rules related to assignment statements:\nAssignment statements are always written with the variable on the left, and an expression on the right. We cannot reverse the statement and say expression = x in programming like we can in math. In mathematical terms, this means an assignment statement is not commutative. The left side of an assignment statement must be a location where a value can be stored. For now, we’re just going to work with single variables, so we don’t have to worry about this yet. In a later lab, we’ll introduce lists as another way to store data, and we’ll revisit this rule. The right side of an assignment statement must be an expression that evaluates to a value that can be stored in the location given on the left side. Right now we’re only working with string values, so we don’t have to worry about this rule yet. We’ll come back to it in a future lab. Using Variables Once we’ve created a variable, we can use it in any expression to recall the current value stored in the variable. So, we can extend our previous example to store a value in a variable, and then use the print(expression) statement to display it’s value. Here’s what that would look like in Python:\nx = \"Hello World\" print(x) Notice that we don’t put quotation marks \" around the variable x in the print(expression) statement. This is because we want to display the value stored in the variable x, not the string value \"x\". So, when we run this code, we should get this output:\nHello World To confirm, feel free to try it yourself! Copy the code above into a Python file, then use the python3 command in the terminal to run the file and see what it does. Running these examples is a great way to learn how a computer actually executes code, and it helps to confirm that your “mental model” of a computer matches how a real computer operates.\nUpdating Variable Values Python also allows us to change the value stored in a variable using another assignment statement. For example, we can write some Python code that uses the same variable to print multiple outputs:\na = \"Output 1\" print(a) a = \"Output 2\" print(a) When we run this code, we’ll see the following output:\nOutput 1 Ouptut 2 So, just like we learned above, when we evaluate a variable in code, it will result in the value currently stored in that variable at the time it is evaluated. So, even though we are printing the same variable twice, each time it is storing a different value. Recall that this is why we call items like a a variable - their value can change!\nVariable Names Finally, Python has a few simple rules that determine what names can be used for variables in our code. Let’s quickly review those rules, as well as some conventions that most Python developers follow when naming variables.\nFirst, the rules that must be followed:\nVariable names must begin with either a letter or an underscore _. Variable names may only contain letters, numbers, and underscores _. Variable names are case sensitive. Next, here are the conventions that most Python developers follow for variable names, which we will also follow in this course:\nVariable names beginning with an underscore _ have a special meaning. So, we won’t create any variables beginning with an underscore right now, but later we’ll learn about what they mean and start using them. Variables should have a descriptive name, like total or average, that makes it clear what the variable is used for. Variables should be named using Snake Case. This means that spaces are represented by underscores _, as in number_of_inputs Try to use traditional variable names only for their specific uses. Some examples of traditional variable names: tmp or temp are temporary variables. i, j, and k are iterator variables (we’ll learn about those later). x, y, and z are coordinates in a coordinate plane. r, g, b, a are colors in an RGB color system. Variables should not have the same name as keywords or any built-in statements or expressions in the language. For example, Python has a print statement, so we should not name a variable print in our language. In general, longer variable names are more useful than short ones, even if they are more difficult to type. These conventions are not strict requirements enforced by the Python language itself, but they are general rules to help us write code that is meaningful and easy to read.\nFinally, don’t forget that some of the code examples in this course will NOT follow these conventions, mainly because long, descriptive variable names might give away the purpose of the code itself. We’ll still follow the rules that are required, but in many cases we’ll use simple variable names so that the focus is learning to read the structure of the code, not inferring what it does based solely on the names of the variables.\n",
    "description": "",
    "tags": null,
    "title": "Variables",
    "uri": "/01-basic-python/06-variables/"
  },
  {
    "content": " Resources Slides Now that we’ve learned all about using loops in Python, let’s go through a complete worked example to see how all the pieces fit together. As we continue to develop larger and more complex programs, it is helpful to observe the entire process from start to finish so we can see how to easily develop a program one step at a time. Once we’ve created our program, we’ll also perform a bit of testing to make sure that it works correctly.\nProblem Statement For this example, let’s write a program to play a simple number guessing game. Here’s how it works:\nThe game will select two random numbers from $ 0 $ to $ 100 $, one for each player. Then, each player will guess a number in the range, and the game will print either “higher” if that player’s secret number is larger than the guess, or “lower” if the player’s secret number is smaller than the guess. Players will alternate turns until one player correctly guesses their secret number and wins the game.\nThis game is pretty simple, but there are still quite a few different parts that we need to build in order to write the entire program. So, let’s go through the process of building a complete program in Python to play this game.\nRandom Numbers Before we start building our program, we need some way to generate a random number. Thankfully, Python has a built-in library called random that has many functions for working with random numbers in our programs.\nTo use a library in Python, we must first import it into our code. This is done using a simple import statement at the very top of our program’s code, followed by the name of the library we want to use. So, for this library, we’ll need to have the following import statement at the top of our source code:\nimport random Once we’ve done that, we can use the function random.randint(a, b) to generate a random number that is between a and b, inclusive. Mathematically, we can say that it generates an integer $ x $ such that $ a \u003c= x \u003c= b $.\nSo, here’s a quick test program we can use to explore how to use random numbers in Python:\nimport random a = int(input(\"Enter a minimum value: \")) b = int(input(\"Enter a maximum value: \")) x = random.randint(a, b) print(f\"A random number between {a} and {b} is {x}\") Take a minute to run this program and modify it a bit to make sure you understand how to work with random numbers in Python before continuing.\nBasic Structure For this program, we need to start by generating two random numbers from $ 0 $ to $ 100 $, one for each player. So, we can create and store those numbers in the code, and we’ll also need to import the random library at the top of our file.\nimport random p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) Once we have the secret numbers, then we can sketch out the game itself. We’ll use a while loop to repeat until a player has guessed correctly, and we’ll also use a simple integer variable to keep track of the current player. Inside of the loop, we should get a new guess from a player, and also switch between players. So, let’s add that to our program structure using some comments:\nimport random p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) player = 1 while( ): # player has not guessed correctly # swap player # get new guess from player # check if secret is higher or lower From here, we can start to work on the actual logic in our program.\nBoolean Expression The trickiest part of this program is coming up with the correct Boolean expression to use in our while loop. That helps us determine if the player has guessed correctly and that the loop should stop. However, this is a bit complex since there are two different players, each one with their own secret number. So, in our Boolean expressions, we have to determine what the current player is as well as whether the most recent guess was correct.\nTo do this, we can use the and and or Boolean operators to combine several Boolean expressions together. For example, we can determine if the current player is player 1 using player == 1, and then we can determine if the most recent guess is equal to player 1’s secret number using guess == p1_secret. If we want both of those to be True in order to exit the loop, we can combine them using the and operator. We can do something very similar for player 2 as well. Then, if we want the loop to terminate if either of those is true, we can combine the two statements using the or operator.\nSo, all together, we want to repeat the loop as long as that entire statement is not True. So, the full Boolean expression would be:\nnot ((player == 1 and guess == p1_secret) or (player == 2 and guess == p2_secret)) That’s pretty complex, but it easily encompasses all of the rules of the game!\nHandling Input To get input from the user, we can write a simple loop to handle input is very similar to the ones we saw earlier in this lab. We simply want to make sure the user has provided a value that is between $ 0 $ and $ 100 $, and prompt the user for another input if not. We’ll also add in a variable to print the current player in the prompt for input.\nSo, our loop to get input might look something like this:\nx = int(input(f\"Enter a guess for player {player}: \")) while x \u003c 0 or x \u003e 100: print(\"Invalid Input!\") x = int(input(f\"Enter a guess for player {player}: \")) Then, in our code, we can simply use the new input loop to read a player’s current guess as shown here:\nimport random p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) player = 1 while(not ((player == 1 and guess == p1_secret) or (player == 2 and guess == p2_secret))): # player has not guessed correctly # swap player x = int(input(f\"Enter a guess for player {player}: \")) while x \u003c 0 or x \u003e 100: print(\"Invalid Input!\") x = int(input(f\"Enter a guess for player {player}: \")) guess = x # check if secret is higher or lower Checking Guess and Swapping Players Next, we need to add some conditional statements to check if the secret is higher or lower than the guess, and also to swap between players. First, let’s look at swapping players. This is pretty simple, since all we need to do is find out what the current player is, and switch that value to the other player. So, we can do that using a simple if statement as shown here:\nimport random p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) player = 1 while(not ((player == 1 and guess == p1_secret) or (player == 2 and guess == p2_secret))): # player has not guessed correctly if player == 1: player = 2 else: player = 1 x = int(input(f\"Enter a guess for player {player}: \")) while x \u003c 0 or x \u003e 100: print(\"Invalid Input!\") x = int(input(f\"Enter a guess for player {player}: \")) guess = x # check if secret is higher or lower The process for checking a guess is very similar - we can simply check to see if the guess is higher or lower than the secret for the current player, and print the output accordingly. First, we’ll need to figure out the current player:\nif player == 1: # check player 1's secret else: # check player 2's secret Then, in each of those branches, we’ll check the guess:\nif player == 1: if guess \u003c p1_secret: print(\"Higher\") elif guess \u003e p1_secret: print(\"Lower\") else: print(\"Correct!\") else: if guess \u003c p2_secret: print(\"Higher\") elif guess \u003e p2_secret: print(\"Lower\") else: print(\"Correct!\") This is a pretty straightforward set of conditional statements, but it goes to show how many lines of code are required even for a simple guessing-game program like this one.\nInitial Testing and Debugging So, at this point, we can put all of the pieces together and test our program. Here is the complete program that we’ve written so far:\nimport random p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) player = 1 while(not ((player == 1 and guess == p1_secret) or (player == 2 and guess == p2_secret))): # player has not guessed correctly if player == 1: player = 2 else: player = 1 x = int(input(f\"Enter a guess for player {player}: \")) while x \u003c 0 or x \u003e 100: print(\"Invalid Input!\") x = int(input(f\"Enter a guess for player {player}: \")) guess = x if player == 1: if guess \u003c p1_secret: print(\"Higher\") elif guess \u003e p1_secret: print(\"Lower\") else: print(\"Correct!\") else: if guess \u003c p2_secret: print(\"Higher\") elif guess \u003e p2_secret: print(\"Lower\") else: print(\"Correct!\") So, let’s try to run this program and see if it works. Unfortunately, right from the start we have an error in our code, since when we try to execute this program, we’ll get the following error:\nTake a minute to see if you can spot and fix the error before continuing!\nUnfortunately, in our Boolean expression inside of the while loop, we’re referencing the guess variable, but that variable isn’t actually created until later inside the while loop itself. So, we’ll need to set the guess variable to a value outside of the while loop first.\nAlso, we must be very careful about what value we use. If we set guess to be $ 0 $ initially, there is a very small chance that player 1 could win the game immediately if their secret number is $ 0 $, since that is a valid guess. Instead, let’s set guess to be $ -1 $ so that it will never be equal to a secret number.\nAfter we make that change, when we run the program again, we may notice one other error:\nCan you spot it by looking at this screenshot?\nUnfortunately, our program starts with player 2’s turn instead of player 1. Why is that? Well, if we look closely at our code, we see that we are initially setting the player to player 1, but then immediately switching players inside of the while loop before we prompt for input. If we think about it, we can’t move the code that swaps players to later in the while loop, because then our Boolean expression to determine if the while loop should terminate will be incorrect. So, instead, we can simply initialize the player variable to be $ 2 $, and then it will be switched to $ 1 $ before we prompt for input the first time.\nSo, our final working program’s code with these two changes is shown here:\nimport random p1_secret = random.randint(0, 100) p2_secret = random.randint(0, 100) player = 2 guess = -1 while(not ((player == 1 and guess == p1_secret) or (player == 2 and guess == p2_secret))): # player has not guessed correctly if player == 1: player = 2 else: player = 1 x = int(input(f\"Enter a guess for player {player}: \")) while x \u003c 0 or x \u003e 100: print(\"Invalid Input!\") x = int(input(f\"Enter a guess for player {player}: \")) guess = x if player == 1: if guess \u003c p1_secret: print(\"Higher\") elif guess \u003e p1_secret: print(\"Lower\") else: print(\"Correct!\") else: if guess \u003c p2_secret: print(\"Higher\") elif guess \u003e p2_secret: print(\"Lower\") else: print(\"Correct!\") A full example of running this program, complete with a very lucky guess, is shown in the screenshot below:\nTesting - Branch and Path Coverage Now that we have a complete and working program, let’s look at what it might take to test it. Unfortunately, testing a program that uses random numbers can be very tricky, since each time you run the program you might receive different outputs even if you provide the same inputs.\nThankfully, we can still perform some testing to achieve branch and path coverage by choosing our guesses carefully. Here are the basic methods we’ll want to try:\nGuessing $ 0 $ for each player should result in \"Higher\" for output, unless the secret number is $ 0 $. Guessing $ 100 $ for each player should result in \"Lower\" for output, unless the secret number is $ 100 $. Guessing the same value for one player while actually playing the game for the other player will eventually result in an output of \"Correct\". Using a bit of logic, it is always possible to win the game in no more than $ 7 $ guesses. Trying to input an invalid value should result in \"Invalid Input!\" for output at least once. Following those simple strategies and keeping track of the various outputs received, it is pretty easy to eventually test all branches and most, if not all, possible paths through the program.\nTesting - Loop Termination Checking for loop termination on this program is a bit trickier, since the secret numbers are random and the guesses that a player makes are also unpredictable. So, while we can’t say for sure that the program will terminate, we can always prove that there is a possible condition where the loop will terminate, and that condition depends entirely on the user providing the correct input. So, as long as it is possible, we can say that the loop is at least not an infinite loop, and the program will work correctly if the user makes the correct guess.\nThere we go! We’ve just explored a complete example of writing a program in Python, complete with loops and conditional statements. We also introduced random numbers and how we can easily use those in our programs. Beyond that, we explored how to test these programs and correct minor errors found in testing. Hopefully this process is very helpful as we continue to work on larger and more complex programs.\n",
    "description": "",
    "tags": null,
    "title": "Worked Example",
    "uri": "/05-loops/06-example/"
  },
  {
    "content": " Resources Slides As we learn to write more complex programs in Python, it is important to make sure we can still mentally execute the code we are writing in our “mental model” of a computer before we actually run it on a computer. After all, if we don’t have at least an idea of what the code actually does before we write it, we really haven’t learned much about programming!\nThankfully, when working in a real programming language such as Python, there are many tools to help us visualize how the code works when we run it. This helps us continue to develop our “mental model” of a computer by looking behind the scenes a bit to see what is happening when we run our code.\nOne such tool is Python Tutor, a website that can quickly run short pieces of Python code to help us visualize what each line does and how it works. This tool is also integrated directly into Codio!\nPython Tutor Example Let’s look at an example of how Python Tutor compares to the manual code traces we performed in a previous lab. For this example, we’re going to use the following code:\nx = \"Hello\" y = x print(y, end=\" \") x = \"World\" print(x, end=\", \") print(y) This visualization can be found by clicking this Python Tutor Link to open Python Tutor on the web.\nStepping Through Code The initial setup for Python Tutor is shown in the image below:\nThis looks similar to the setup we used when performing code tracing with pseudocode. We have an arrow next to our code that is keeping track of the next line to be executed, and we have areas to the side to record variables and outputs. In Python Tutor, the variables are stored in the Frames section. We’ll learn why that is important later in this lab when we start looking at Python functions.\nSo, let’s click the Next \u003e button once to execute the first line of code. After we do that, we should see the following setup in Python Tutor:\nThat line is an assignment statement, so Python Tutor added an entry in the Frames section for the variable x, showing that it now contains the string value \"Hello\". It placed that variable in a frame it is calling the “Global frame,” which simply contains variables that are created outside of a function in Python.\nWhen we click the Next \u003e button again, we should see this:\nOnce again, the line that was just executed is an assignment statement, so Python Tutor will add a new variable entry for y to the list of variables. It will also store the string value \"Hello\". Just like before, notice that the variable y is storing the same value as x, but it is a copy of that value. The variables are not connected in any other way.\nWe can click Next \u003e again to execute the next line of code:\nOnce this line is executed, we’ll see that it prints the value of the variable y to the output. Python Tutor will look up the value of y in the Frames section and print it in the output, but it won’t evaluate the expression in the code like we did when we performed code tracing in pseudocode. It’s a subtle difference, but it is worth noting.\nOnce again, we can click Next \u003e to execute the next assignment statement:\nThis statement will update the value stored in the variable x to be the string value \"World\". After that, we can run the next statement:\nThat statement prints the value of x to the output, followed by a comma , and a space as shown in the end argument provided to the print function. Finally, we can click Next \u003e one more time to execute the last line of code:\nThis will print the value of y to the output. Once the entire program has been executed, we should see the output Hello World, Hello printed to the screen.\nThe full process is shown in the animation below:\nUsing tools like Python Tutor to step through small pieces of code and understand how the computer interprets them is a very helpful way to make sure our “mental model” of a computer accurately reflects what is going on behind the scenes when we run a piece of Python code on a real computer. So, as we continue to show and discuss examples in this course, feel free to use tools such as Python Tutor, as well as just running the code yourself, as a great way to make sure you understand what the code is actually doing.\n",
    "description": "",
    "tags": null,
    "title": "Code Tracing",
    "uri": "/01-basic-python/07-code-tracing/"
  },
  {
    "content": " Resources Slides Python also supports another kind of conditional statement, the if-else statement. An if-else statement contains a single Boolean expression, but two blocks of code. If the Boolean expression evaluates to True, then one block of statements is executed. If it is False, then the other block will be executed.\nThe general structure of an if-else statement in Python is shown below:\nif \u003cboolean expression\u003e: \u003cblock of statements 1\u003e else: \u003cblock of statements 2\u003e Notice that the else keyword is followed by a colon, just like the first line of the if-else statement. As we’d expect, the first block of statements is executed if the \u003cboolean expression\u003e portion is True and the second block is executed if it is False.\nOnce again, let’s go through a couple of code traces using Python Tutor to explore how an if-else statement works in Python.\nCode Tracing Example - True Here’s a simple Python program that contains an if-else statement:\nx = int(input(\"Enter a number: \")) if x \u003e= 0: print(\"Your number is positive!\") else: print(\"Your number is negative\") print(\"Thanks for playing!\") This program accepts an input from the user, converts it to an integer, and then determines if the integer is a positive or negative number. Let’s go through this program a couple of times in Python Tutor to see how it works. As always, you can copy and paste this code into Python Tutor, or click this Python Tutor link to follow along!\nWe’ll start an input prompt as shown here:\nLet’s assume that the user inputs the string \"5\" here.\nThat means that the integer value $ 5 $ will be stored in the variable named x:\nNow we’ve reached the if-else statement. So, we’ll need to evaluate the Boolean expression x \u003e= 0. Since x is currently storing the value $ 5 $, this expression will evaluate to True. Therefore, we’ll move into the first block of statements in the if-else statement:\nFrom here, we’ll print the message that the user’s input was a positive number, as well as the goodbye message at the end of the program. It will entirely skip the second block of statements in the if-else statement, as we can see here:\nA full execution of this program is shown in the animation below:\nCode Tracing Example - False What if the user inputs a negative value, such as $ -7 $? In that case, we’ll be at this state in our program:\nFrom here, we’ll evaluate the Boolean expression x \u003e= 0 again. This time, however, we’ll see that it evaluates to False, so we’ll jump down to the second block of statements inside the if-else statement:\nThis will print a message to the user that the input was a negative number, and then it will print the goodbye message. We completely skipped the first block of statements:\nA complete run through this program is shown in this animation:\nSo, as we expect, an if-else statement allows us to run one block of statements or the other, based on the value of the Boolean expression. It is a very powerful piece of code, and it allows us to write programs that perform different actions based on the input provided by the user or the values of other variables.\nIf-Else Statement Flowchart Another way to visualize an if-else statement is using a flowchart. Consider the following Python code:\nx = int(input(\"Input: \" )) if x \u003e= 0: print(x) else: print(-1 * x) print(\"Goodbye\") This code can also be represented as the flowchart shown below:\nOnce again, we start at the top of the flowchart at the circle labeled “START”. From there, we read an input from the user and store it in the variable x. At this point, we reach our if-else statement’s decision node, represented by the diamond. Here, we are using the Boolean expression x \u003e= 0 to determine which branch to follow. So, if the user inputs a positive value, then we’ll follow the path to the right that is labeled “True”, which will simply print the value of x to the screen.\nHowever, if the user inputs a negative value for x, then the Boolean expression will be False and we’ll follow the path to the left labeled “False”. In this branch, we’ll print the value of (-1 * x) to the screen, which simply removes the negative sign from the value in x.\nFinally, after each path, we’ll merge back together to run the last piece of code, which prints the \"Goodbye\" message to the screen.\nNotice that there is no way to print both x and -1 * x in the same execution of this program. If we follow the arrows through the flowchart, we see that we can only follow one branch or the other, and not both. This is an important concept to remember when working with if-else statements! The control flow of the program can only pass through one of the two blocks of statements, but not both.\n",
    "description": "",
    "tags": null,
    "title": "If-Else",
    "uri": "/04-conditionals/07-if-else/"
  },
  {
    "content": "Let’s try some simple practice problems. These problems are not graded - they are just for you to practice before doing the real exercises in the lab itself. You can find the answers below each question by clicking the button below each question.\n5.1 Reading Code Consider the following pseudocode program:\nx = int(input(\"Enter a positive integer: \")) while(x \u003c= 0): print(\"Invalid Input!\") x = int(input(\"Enter a positive integer: \")) a = 1 for i in range(9): if x % a == 0: print(f\"{a}\") a = a + 1 Explain, in your own words, the output that this program produces in relation to the input provided.\nA fully correct answer is a succinct description of the output as it relates to the input. A partially correct answer is a step-by-step description of each line in the program and the output it will produce based on the input.\nAnswer 5.1 Answer This program receives a positive number as input, and then will check to see if that number is evenly divisible by the numbers $ 1 $ through $ 9 $. If so, it will print that number.\nFor example, if the input provided is $ 60 $, then the output should be:\n1 2 3 4 5 6 since $ 60 $ is divisible by the first $ 6 $ integers.\n5.2 Testing Code Consider the program above. Devise a set of inputs that will cause each of the 9 possible numerical outputs to print at least once, and for each input, list the numbers that will be printed as output.\nAnswer 5.2 Answer There are many ways to answer this. A quick and easy way is to simply provide the numbers $ 1 $ through $ 9 $ as inputs. In the previous answer, we already know that $ 60 $ covers six of the nine possible outputs, so two or three additional inputs can cover the rest.\nMathematically, the number $ 2520 $ is the lowest common multiple of the first ten integers, so that single value as input will produce all nine possible outputs.\n5.3 Reading Code Consider the following Python program:\nx = int(input(\"Enter a positive integer: \")) while(x \u003c= 0): print(\"Invalid Input!\") x = int(input(\"Enter a positive integer: \")) a = \"\" while x \u003e 0: if x % 2 == 0: a = \"0\" + a else: a = \"1\" + a x = x // 2 print(a) Explain, in your own words, the output that this program produces in relation to the input provided.\nA fully correct answer is a succinct description of the output as it relates to the input. A partially correct answer is a step-by-step description of each line in the program and the output it will produce based on the input.\nHint: when numbers are stored digitally on a computer, what numerical format is used?\nAnswer 5.3 Answer Simply put, this program will convert any positive integer into its binary representation. For example, the input $ 42 $ will generate the output 101010, which is in binary is the value $ 42 $.\n5.4 Testing Code Consider the Python program above. Devise a set of inputs that you feel are sufficient to test the program, and briefly explain why those inputs are sufficient.\nHint: Achieving coverage is very simple, but providing enough input to be confident that the program is generating the correct output should also be considered.\nAnswer 5.4 Answer To achieve full coverage, a sufficient set of inputs would be something similar to:\n0 1 2 That should be enough to exercise all possible code branches and paths. However, in order to truly determine if the program is producing the correct output, it would be useful to choose a couple of larger inputs. Some good choices would be numbers near a power of $ 2 $, such as:\n15 16 Many other answers are possible here.\n5.5 Writing Code Write a complete Python program that meets the specification below.\nThe Fibonacci Sequence is a sequence of numbers where the next number is the sum of the previous two numbers. The sequence starts with the numbers $ 1 $ and $ 1 $, making the next number $ 2 $. The following number is $ 3 $, since it is the sum of the second and third number of the sequence. The sequence continues indefinitely.\nFor this program, ask the user to input a number that must be greater than $ 5 $. If the user inputs a number that is $ 5 $ or less, display an error and prompt the user for another input until a valid input is received.\nThen, determine if the number provided as input is part of the Fibonacci Sequence. This can be done by computing the sequence one number at a time until the desired number is reached or passed. Print either \"In sequence\" or \"Not in sequence\" depending on the result found.\nAnswer 5.5 Answer One possible solution is given below:\nx = int(input(\"Enter a positive integer greater than 5: \")) while(x \u003c= 5): print(\"Invalid Input!\") x = int(input(\"Enter a positive integer greater than 5: \")) a = 1 b = 1 while b \u003c x: c = a + b a = b b = c if b == x: print(\"In sequence\") else: print(\"Not in sequence\") There are many other valid approaches as well.\n5.6 Writing Code Write a complete Python program that meets the specification below.\nWrite a program that will print the first $ 30 $ multiples of a given number, but only multiples where the last digit is equal to a second given number.\nFor this program, ask the user to provide two integers - the first between $ 1 $ and $ 100 $, inclusive, and the second between $ 0 $ and $ 9 $, inclusive. If the user provides an invalid value for either input, print an error message and prompt the user for another input until a valid input is received.\nThen, the program should compute the first $ 30 $ multiples of the first given number. This would be equivalent to multiplying the number by $ 1 $ all the way through multiplying the number by $ 30 $. Then, if that computed multiple ends with the same digit as the second number, it should be printed. Otherwise, no output is produced for that number.\nFor example, if the first given number is $ 9 $ and the second number is $ 1 $, then the output should be:\n81 171 261 Your program should make use of a for loop and the Python range() function.\nHint: what is the value of 81 % 10? What about 27 % 10? Does that value help you determine whether the number should be printed or not?\nAnswer 5.5 Answer One possible solution is given below:\nx = int(input(\"Enter an integer between 1 and 100: \")) while(x \u003c 1 or x \u003e 100): print(\"Invalid Input!\") x = int(input(\"Enter an integer between 1 and 100: \")) first = x x = int(input(\"Enter an integer between 0 and 9: \")) while(x \u003c 0 or x \u003e 9): print(\"Invalid Input!\") x = int(input(\"Enter an integer between 0 and 9: \")) second = x for i in range(first, first * 30 + 1, first): if i % 10 == second: print(i) This solution uses the range() function directly to compute the multiples. It is also possible to use range() to generate a list of numbers from $ 1 $ to $ 30 $ and compute the multiples using those values.\n",
    "description": "",
    "tags": null,
    "title": "Loops Practice",
    "uri": "/05-loops/07-loops-practice/"
  },
  {
    "content": " Resources Slides Finally, just like in mathematics, we must also be aware of the order that these operators are applied, especially if they are combined into a single expression. Thankfully, the same rules we learned in mathematics apply in programming as well. Specifically, operators in Python are applied in this order:\nOperations in parentheses are resolved first, moving from left to right. ** is resolved second, moving from left to right *, /, // and % are resolved third, moving from left to right. + and - are resolved fourth, moving from left to right. You might recall the “PEMDAS” acronym for remembering the order of operations in math, and thankfully it still applies here. Of course, this means that there are now 4 operators that all fit in the “multiplication and division” portion, so we have to carefully make sure they are all taken care of in the correct way.\nAlso, as you’ve probably already learned in math, it is always best to add extra parentheses to any expression to make the intent very clear instead of relying on the order of operations. So, when in doubt, use extra parentheses wherever needed!\nLet’s work through a quick example just to see the order of operations in practice. Here’s a complex expression in Python that we can try to evaluate:\nx = 8 / 4 + 5 * (3 + 1) - 7 % 4 Looking at our order of operations, the first step is to handle any expressions inside of parentheses. So, we’ll first start with the expression (3 + 1) and evaluate it to 4.\nx = 8 / 4 + 5 * 4 - 7 % 4 Then, we’ll go left to right and perform any multiplication, division, and modulo operations. This means we’ll evaluate 8 / 4, 5 * 4 and 7 % 4 and replace them with the resulting values:\nx = 2.0 + 20 - 3 Notice that 8 / 4 was reduced to 2.0 instead of just 2. This is because the division operator is the one exception to the rule where an operator applied to two integers will result in an integer. The division operator always produces a floating-point value.\nFinally, we’ll perform addition and subtraction from left to right. So, we’ll evaluate 2.0 + 20 first, and then subtract 3 from the result of that operation. At the end, we’ll have this statement:\nx = 19.0 So, we were able to use our knowledge of the order of operations to evaluate that complex expression to a single value, $ 19.0 $, which will be stored in the variable x.\n",
    "description": "",
    "tags": null,
    "title": "Order of Operations",
    "uri": "/02-numbers/07-order-of-operations/"
  },
  {
    "content": "Python input input(expression) will display the expression to the user as a prompt, then return what was typed by the user as a string value. input(expression) is terminated by the user pressing ENTER, so next output starts on a new line. Python String Operators + Concatenation (join strings together). May only be applied to two strings. * Repeat (duplicate strings) \\ Escape Operator for special characters f-string are used to format output. Template strings include curly braces as placeholders {} and inside the placeholder is any variable or expression to be printed in that location in the template string. Complex Statements Expressions can be combined in many ways within a statement. Expressions can be used as arguments to functions, and more!\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/03-strings-input/07-summary/"
  },
  {
    "content": "Let’s try some simple practice problems. These problems are not graded - they are just for you to practice before doing the real exercises in the lab itself. You can find the answers below each question by clicking the button below each question.\n2.1 Reading Code Write the output that is displayed to the user after running the following Python code:\nx = 13 z = \"5\" y = int(z) var = (x + y) % y * y - x var = var / 2 print(var) Pay special attention to data types! Make sure the answer is presented as the correct type.\nAnswer 2.1 Answer The correct answer is\n1.0 Following order of operations, we do parentheses first:\n(x + y) % y * y - x (13 + 5) % 5 * 5 - 13 18 % 5 * 5 - 13 Then we will do multiplication and modulo left to right. Recall that % is the modulo operation, so 18 % 5 is the remainder of 18 / 5, which is 3:\n18 % 5 * 5 - 13 3 * 5 - 13 15 - 13 Finally, we do subtraction:\n15 - 13 2 The last line will compute 2 / 2, which is just 1.0. Recall that the division operation always produces a float, not an integer.\n2.2 Reading Code Write the output that is displayed to the user after running the following Python code:\nx = 9 y = 3.0 z = 5 ans = (x - z) % 2 // y + z ** (y - 1) print(ans) Pay special attention to data types! Make sure the answer is presented as the correct type.\nAnswer 2.2 Answer The correct answer is:\n25.0 Following order of operations, we do parentheses first:\n(x - z) % 2 // y + z ** (y - 1) (9 - 5) % 2 // 3.0 + 5 ** (3.0 - 1) 4 % 2 // 3.0 + 5 ** 2.0 Then, we’ll perform all multiplication, division, modulo, and integer division from left to right:\n4 % 2 // 3.0 + 5 ** 2.0 0 // 3.0 + 5 ** 2.0 0.0 + 5 ** 2.0 0.0 + 25.0 Finally, we’ll perform addition to find the answer of 25.0.\n2.3 Writing Code You are teaching a class and would like to put your students into a number of groups. You know how many students are in the class and the number of groups to create, but you aren’t sure how many students should be in each group.\nWe’ll assume that these values are stored in the students and groups variables, respectively.\nWrite a Python program to compute the ideal group size for each group in the class. When divided, the groups in the class should have no fewer than size people, and no more than size+1 people, and there should be exactly groups groups total. For example, if there are $ 15 $ people and the desired number of groups is $ 4 $, then code should start with the following two variable assignments.\nstudents = 15 groups = 4 # more code goes here Your code should produce the following output for these values:\ngroups of 3 or 4 This is because the ideal group size for $ 4 $ groups out of $ 15 $ people is $ 3 $, and all groups should have either $ 3 $ or $ 4 $ members (in this case, one group of $ 3 $ and the rest groups of $ 4 $).\nWrite the rest of this Python program. Try different values for the students and groups variables to make sure that your answers are correct!\nAnswer 2.3 Answer One possible answer:\nstudents = 15 groups = 4 # more code goes here size = students // groups print(\"groups of \", end=\"\") print(size, end=\"\") print(\" or \", end=\"\") size = size + 1 print(size) The values in the students and groups variables can be changed. The key is to use the integer division operator to determine the size of each group, though some groups may have 1 more member if there is a remainder. You can even use the modulo operator to determine how many groups will get an extra member!\n",
    "description": "",
    "tags": null,
    "title": "Math Practice",
    "uri": "/02-numbers/08-math-practice/"
  },
  {
    "content": " Resources Slides Up to this point, we explored how we can use iterative structures in our code, such as while loops and for loops, to repeat steps a certain number of times or while a Boolean condition is true. This is a very powerful tool, since it allows us to build programs that can repeatedly ask the user to provide input until a valid value is received, or even perform a repeated calculation until it reaches a desired result.\nLoops, just like conditional statements, can also be nested inside of one another, allowing us to build even more complex programs. In fact, you may have already done this using loops and code that contains loops in a previous lab without realizing it. Next, we’ll explore how to combine loops in many different ways, and learn how we can test and debug these complex programs.\nLater in this course, we’ll learn about two different collection types in Python, and we’ll quickly see how we can use loops to work with them quickly and easily.\nNested While Loops To create a nested loop in Python, we can simply place a loop structure inside of the block of statements that is repeated by another loop structure. This is very similar to how we can nest conditional statements as well.\nFor example, consider this short Python program:\ni = 1 while i \u003c 10: j = i while j \u003c 10: print(f\"{j} \", end=\"\") j = j + 1 print(\"\") i = i + 1 print(\"Complete!\") In this example, we see a Python while loop that uses the variable i in its Boolean expression first, and then inside of that loop we see another loop that uses j in its Boolean expression. When we run this code, each time we execute the steps inside of the outer while loop, we’ll have to completely go through the inner while loop as well. It can be very complex to keep track of everything, but with a bit of practice we’ll learn some strategies for mentally working through loops.\nBefore continuing, take a look at that program’s code and see if you can determine what it will print!\nCode Tracing Example To really understand how a set of nested loops work, let’s go through a code tracing example using Python Tutor. To follow along, copy this code to Python Tutor or click this Python Tutor link to load Python Tutor in a web browser.\nWhen we first load this code in Python Tutor, we should see the following state:\nWhen we look at the bottom of the Python Tutor page, we’ll see that we are on step 1 of 183 steps! That’s a very large number of steps to deal with! Up to this point, most of our programs have been around 20 or 30 steps in total. So, already we’re seeing that nested loops can quickly create programs that execute many more steps.\nHere, we are setting up the iterator variable i that is used for the outermost loop. So, we’ll store the value $1$ in i and then move to the next line:\nNow we’re at the start of our outer while loop. That means that we’ll need to evaluate the Boolean expression and determine if it is True or False. In this case, we can see that i \u003c 10 will evaluate to True, so we should enter the loop.\nOnce we are inside the loop, we’ll start setting up the iterator variable j for the inner loop. In this code, we are storing the current value of i in j, so at this point j will also contain $1$.\nAt this point, we need to decide if we should enter the inner while loop. So, once again we’ll look at the Boolean expression, j \u003c 10, and see that it is also True and we should enter the loop.\nInside of the inner while loop, we’ll perform two actions. First, we’ll print the current value of j to the output, but we won’t move to the next line since the end parameter is set to an empty string in the print() function:\nThen, we’ll increment the value of j by $1$ before looping back to the top of the innermost loop:\nNotice that when we reach the end of the innermost loop, we jump back to the beginning of that loop, NOT to the beginning of the outermost loop. This is an important concept to learn - since we are only dealing with the inner loop at this point, we must continue to repeat its steps until the Boolean expression evaluates to False. So, since the Boolean expression j \u003c 10 still evaluates to True, we should enter the loop once again.\nInside the loop, we’ll print the current value of j to the same line of output as before:\nAnd once again we’ll increment the value of j by $1$ and jump back to the top of the innermost while loop:\nHopefully at this point we have a pretty good idea of what each step of the innermost while loop does. It will simply print the value of j and increment it by $1$, repeating those steps until j is greater than or equal to $10$. So, once the inner while loop terminates, we’ll see this state:\nWe jumped from step 10 to step 32 just to complete the inner while loop. Finally, at this point we’ll print an empty string, which will move our output to the next line, and then we’ll increment the value in i by $1$ before looping to the top of the outer while loop:\nNow we must check to see if we should enter the outer while loop again by checking the Boolean expression i \u003c 10. Since that evaluates to True, we’ll enter the loop a second time.\nInside the loop, we’ll reset the value of j to be the current value stored in i, which is now $2$, and then we’ll reach the inner while loop:\nHere, we can evaluate the Boolean expression j \u003c 10, which is currently True, and determine that we should enter the inner while loop.\nInside the loop, the code hasn’t changed, so we can use our understanding from before to quickly figure out what this loop does. It will print the current value in j and then increment j by $1$, so we’ll end up at this state:\nAt this point, we can easily assume that the inner loop will do pretty much the same thing as before - it will print all of the values from i up through $9$ to the output, all on the same line. So, once the inner loop has completely finished, we’ll see the following state in Python Tutor:\nWe were able to quickly jump from step 42 all the way to step 64 just by understanding what the inner loop is doing and extrapolating from our previous experience. Now, we can finish up this iteration of the outer loop by printing a newline and then incrementing i by $1$, and then we’ll be back at the beginning of the outer while loop:\nAt this point, we’ve completely worked through two iterations of the outermost while loop, including two complete executions of the innermost while loop. So, we’re at a good point to make a prediction about the output of the program as a whole, without executing the next 120 steps. It looks like the inner loop will print the values from i through $9$ on a single line, and then each line will start with the value of i being incremented by $1$ each time. So, overall, we can expect the entire outer while loop to produce the following output:\n1 2 3 4 5 6 7 8 9 2 3 4 5 6 7 8 9 3 4 5 6 7 8 9 4 5 6 7 8 9 5 6 7 8 9 6 7 8 9 7 8 9 8 9 9 And, indeed, if we jump ahead to the last line of the program we’ll see exactly that situation in Python Tutor:\nThe program ends by printing the string \"Complete!\". At the end of the program, we’ll see the following state:\nWorking through an example program such as this one is a great way to explore how nested loops work in Python\nTips for Nested Loops Writing code that has nested while loops can be quite tricky, as there are several pitfalls that we might encounter. Here are a few tips to keep in mind when designing code that uses nested while loops:\nTry to understand the relationship between each loop’s Boolean expression. If possible, use different variables in each one. It is easy to write code where the Boolean expressions are closely related, causing an infinite loop to occur. Look for ways to combine the nested loops into a single loop if possible. While this may not always be an option, it can make reasoning about the code much simpler. Try to make the loops as simple as possible. It is much easier to debug loops that use a simple iterator that increments regularly instead of a complex Boolean expression. Likewise, try to build loops that either both increment or both decrement the iterator variable to maintain consistency. Nested loops present a very difficult challenge for programmers, because they are short snippets of code that may end up resulting in hundreds or even thousands of individual steps to be executed. So, anything we can do to make the loops simpler and easier to understand will greatly improve our ability to write programs with fewer bugs.\n",
    "description": "",
    "tags": null,
    "title": "Nested While Loops",
    "uri": "/05-loops/08-nested-while/"
  },
  {
    "content": " Resources Slides One important concept to understand when writing if statements and if-else statements is the control flow of the program. Before we learned about conditional statements, our programs had a linear control flow - there was exactly one pathway through the program, no matter what. Each time we ran the program, the same code would be executed each time in the same order. However, with the introduction of conditional statements, this is no longer the case.\nBecause of this, testing our programs becomes much more complicated. We cannot simply test it once or twice, but instead we should plan on testing our programs multiple times to make sure they work exactly the way we want. So, let’s go through some of the various ways we can test our programs that include conditional statements.\nSimple Example First, let’s consider this example program:\nx = int(input(\"Enter a number: \")) y = int(input(\"Enter a number: \")) if x + y \u003e 10: print(\"Branch 1\") else: print(\"Branch 2\") if x - y \u003e 10: print(\"Branch 3\") else: print(\"Branch 4\") We can represent the two if-else statements in this program in the following flowchart as well:\nBranch Coverage First, let’s consider how we can achieve branch coverage by executing all of the branches in this program. This means that we should test the program using different sets of inputs that will run different branches in the code. Our goal is to execute the code in each branch at least once. In this example, we see that there are four branches, helpfully labeled with the numbers one through four in the print() statements included in each branch.\nSo, let’s start with a simple set of inputs, which will store $ 6 $ in both x and y. Which branches will be executed in this case? Before reading ahead, see if you can work through the code above and determine which branches are executed?\nIn the first if-else statement, we’ll see the x + y is equal to $ 12 $, which is greater than $ 10 $, making that Boolean statement True. So, we’ll execute the code in branch 1 this time through. When we reach the second if-else statement, we’ll compute the value of x - y to be $ 0 $, which is less than $ 10 $. In this case, that makes the Boolean statement False, so we’ll execute branch 4. Therefore, by providing the inputs 6 and 6, we’ve executed the code in branches 1 and 4.\nSo, can we think of a second set of inputs that will execute the code in branches 2 and 3? That can be a bit tricky - we want to come up with a set of numbers that add to a value less than $ 10 $, but with a difference that is greater than $ 10 $. However, we can easily do this using negative numbers! So, let’s assume that the user inputs $ 6 $ for x and $ -6 $ for y. When we reach the first if-else statement, we can compute the result of x + y, which is $ 0 $. That is less than $ 10 $, so the Boolean statement is False and we’ll execute the code in branch 2. So far, so good!\nNext, we’ll reach the second if-else statement. Here, we’ll compute the result of x - y. This time, we know that $ 6 - -6 $ is actually $ 12 $, which is greater than $ 10 $. So, since that Boolean expression is True, we’ll run the code in branch 3. That’s exactly what we wanted!\nTherefore, if we want to test this program and try to execute all the branches, we only have to provide two pairs of inputs:\n$ 6 $ and $ 6 $ $ 6 $ and $ -6 $ However, that’s only one way we can test our program. There are many other methods we can follow!\nPath Coverage A more thorough way to test our programs is to achieve path coverage. In this method, our goal is to execute all possible paths through the program. This means that we want to execute every possible ordering of branches! So, since our program has 4 branches in two different if-else statements, the possible orderings of branches are listed below:\nBranch 1 -\u003e Branch 3 Branch 1 -\u003e Branch 4 Branch 2 -\u003e Branch 3 Branch 2 -\u003e Branch 4 As we can see, there are twice as many paths as there are branches in this case! We’ve already covered ordering 2 and 3 from this list, so let’s see if we can find inputs that will cover the other two orderings.\nFirst, we want to find a set of inputs that will execute branch 1 followed by branch 3. So, we’ll need two numbers that add to a value greater than 10, but their difference is also greater than 10. So, let’s try the value $ 12 $ for x and $ 0 $ for y. In that case, their sum is greater than $ 10 $, so we’ll execute branch 1 in the first if-else statement. When we reach the second if-else statement, we can evaluate x - y and find that it is also $ 12 $, which is greater than $ 10 $ and we’ll execute branch 3. So, we’ve covered the first ordering!\nThe last ordering can be done in a similar way - we need a pair of inputs with a sum less than $ 10 $ and also a difference less than $ 10 $. A simple answer would be to input $ 4 $ for both x and y. In this case, their sum is $ 8 $ and their difference is $ 0 $, so we’ll end up executing branch 2 of the first if-else statement, and branch 4 of the second if-else statement. So, that covers the last ordering.\nAs we can see, path coverage will also include branch coverage, but it is a bit more difficult to achieve. If we want to cover all possible paths, we should test our program with these 4 sets of inputs now:\n$ 6 $ and $ 6 $ $ 6 $ and $ -6 $ $ 12 $ and $ 0 $ $ 4 $ and $ 4 $ There’s still one more way we can test our program, so let’s try that out as well.\nEdge Cases Finally, we should also use a set of inputs that test the “edges” of the Boolean expressions used in each if-else statement. An edge is a value that is usually the smallest or largest value before the Boolean expression’s output would change. So, an edge case is simply a set of input values that are specifically created to be edges for the Boolean expressions in our code.\nFor example, let’s look at the first Boolean logic statement, x + y \u003e 10. If we are simply considering whole numbers, then the possible edge cases for this Boolean expression are when the sum of x + y is exactly $ 10 $ and $ 11 $. When it is $ 10 $ or below, the result of the Boolean expression is False, but when the result is $ 11 $ or higher, then the Boolean expression is true. So, $ 10 $ and $ 11 $ represent the edge between True values and False values. The same applies to the Boolean expression in the second if-else statement.\nSo, to truly test the edge cases in this example, we should come up with a set of values with the sum and difference of exactly $ 10 $ and exactly $ 11 $. For the first one, a very easy solution would be to set x to $ 10 $ and y to $ 0 $. In this case, both the sum and the difference is $ 10 $, so we’re on the False side of the edge. Our program will correctly execute branches 2 and 4.\nFor the other edge, we can use a similar set of inputs where x is $ 11 $ and y is still $ 0 $. In this case, both the sum and difference is $ 11 $, so each Boolean expression will evaluate to True and we’ll execute branches 1 and 3.\nWhy is this important? To understand that, we must think a bit about what was intended by this program. What if the program should execute branches 1 and 3 if the value is greater than or equal to $ 10 $? In that case, both of our chosen edge cases should execute branches 1 and 3, but instead we saw that the edge case $ 10 $ executed branches 2 and 4 instead. This is a simple logic error that happens all the time in programming - we simply forgot to use the greater than or equal to symbol \u003e= instead of the simple greater than symbol \u003e in our code. So, a minor typo like that can change the entire execution of our program, and we wouldn’t have noticed it in any of our previous tests. This is why it is important to test the edge cases along with other inputs.\nIn fact, it would probably be a good idea to add a third edge case, where the sum and difference equal $ 9 $, just to be safe. That way, we can clearly see the difference between True and False values in this program.\nSo, the final set of values we may want to test this program with are listed below:\n$ 6 $ and $ 6 $ (branch coverage 1 and 4) $ 6 $ and $ -6 $ (branch coverage 2 and 3) $ 12 $ and $ 0 $ (path coverage 1 and 3) $ 4 $ and $ 4 $ (path coverage 2 and 4) $ 9 $ and $ 0 $ (edge case 2 and 4) $ 10 $ and $ 0 $ (edge case 2 and 4) $ 11 $ and $ 0 $ (edge case 1 and 3) As we can see, even a simple program with just a few lines of code can require substantial testing to really be sure it works correctly! This doesn’t even include other types of testing, where we make sure it works properly with invalid input values, decimal numbers, and other situations. That type of testing is really outside of the scope of this lab, but we’ll learn more about some of those topics later in this course.\nComplex Example Let’s go through one more example to get some more practice with creating test inputs for conditional statements. For this example, let’s consider the following program in Python:\na = int(input(\"Enter a number: \")) b = int(input(\"Enter a number: \")) if a // b \u003e= 5: # Branch 1 print(f\"{b} goes into {a} at least 5 times\") else: # Branch 2 print(f\"{a} is less than 5 times {b}\") if a % b == 0: # Branch 3 print(f\"{b} evenly divides {a}\") else: # Branch 4 print(f\"{a} / {b} has a remainder\") This program is a bit trickier to evaluate. First, it accepts two numbers as input. Then, it will check to see if the first number is at least 5 times the second number. It will print an appropriate message in either case. Then, it will check to see if the first number is evenly divided by the second number, and once again it will print a message in either case.\nBranch Coverage To achieve branch coverage, we need to come up with a set of inputs that will cause each print statement to be executed. Thankfully, the branches are numbered using comments in the Python code, so it is easy to keep track of them.\nLet’s start with an easy input - we’ll set a to $ 25 $ and b to $ 5 $. This means that a // b is equal to $ 5 $, so we’ll go into branch 1 in the first if statement. The second if statement will go into branch 3, since a % b is exactly $ 0 $ because $ 5 $ stored in b will evenly divide the $ 25 $ stored in a without any remainder. So, we’ve covered branches 1 and 3 with this input.\nFor another input, we can choose $ 21 $ for a and $ 5 $ for b. In the first if statement, we’ll see that a // b is now $ 4 $, so we’ll go into branch 2 instead. Likewise, in the second if statement we’ll execute branch 4, since a % b is equal to $ 1 $ with these inputs. That means we’ve covered branches 2 and 4 with these inputs.\nTherefore, we can achieve branch coverage with just two inputs:\n$ 25 $ and $ 5 $ $ 21 $ and $ 5 $ Path Coverage Recall that there are four paths through a program that consists of two if statements in a row:\nBranch 1 -\u003e Branch 3 Branch 1 -\u003e Branch 4 Branch 2 -\u003e Branch 3 Branch 2 -\u003e Branch 4 We’ve already covered the first and last of these paths, so we must simply find inputs for the other two.\nOne input we can try is $ 31 $ and $ 5 $. In the first if statement, we’ll go to branch 1 since a // b will be $ 6 $ this time. However, when we get to the second if statement, we’ll find that there is a remainder of $ 1 $ after computing a % b, so we’ll go to branch 4 instead. This covers the second path.\nThe third path can be covered by inputs $ 20 $ and $ 5 $. In the first if statement, we’ll go to branch 2 because a // b is now $ 4 $, but we’ll end up in branch 3 in the second if statement since a % b is exactly 0.\nTherefore, we can achieve path coverage with these four inputs:\n$ 25 $ and $ 5 $ $ 21 $ and $ 5 $ $ 31 $ and $ 5 $ $ 20 $ and $ 5 $ Edge Cases What about edge cases? For the first if statement, we see the statement a // b \u003e= 5, so that clues us into the fact that we’ll probably want to try values that result in the numbers $ 4 $, $ 5 $, and $ 6 $ for this statement. Thankfully, if we look at the inputs we’ve already tried, we can see that this is already covered! By being a bit deliberate with the inputs we’ve been choosing, we can not only achieve branch and path coverage, but we can also choose values that test the edge cases for various Boolean expressions as well.\nLikewise, the Boolean statement in the second if statement is a % b == 0, so we’ll want to try situations where a % b is exactly $ 0 $, and when it is some other value. Once again, we’ve already covered both of these instances in our sample inputs!\nSo, with a bit of thinking ahead, we can come up with a set of just 4 inputs that not only achieve full path and branch coverage, but also properly test the various edge cases that are present in the program!\n",
    "description": "",
    "tags": null,
    "title": "Testing Branches \u0026 Paths",
    "uri": "/04-conditionals/08-branch-path-testing/"
  },
  {
    "content": "Let’s try some simple practice problems. These problems are not graded - they are just for you to practice before doing the real exercises in the lab itself. You can find the answers below each question by clicking the button below each question.\n1.4 Reading Code Write the output that is displayed to the user after running the following Python code:\na = \"two\" b = a c = a print(c, end=\" \") c = \"one\" b = c a = \"three\" print(a, end=\" \") print(c) Answer 1.4 Answer The correct answer is:\ntwo three one 1.5 Constructing Code We want to write a program that produces the following output:\nand a 1 and a 2 and a 3 Rearrange the following Python statements to create a program that produces that output. You may not use all of these statements in your answer.\nx = \"1\" x = \"2\" x = \"3\" print(x) print(x) print(x) print(\"and a\", end=\" \") print(\"and a\", end=\" \") print(\"and a\", end=\" \") Answer 1.5 Answer One possible answer is given below:\nx = \"1\" print(\"and a\", end=\" \") print(x) x = \"2\" print(\"and a\", end=\" \") print(x) x = \"3\" print(\"and a\", end=\" \") print(x) 1.6 Writing Code We wish to write a Python program that displays the following output:\nabba banana bandana We currently have the following code:\na = \"abba\" b = \"banana\" c = \"bandana\" # more code goes here print(c, end=\" \") print(b, end=\" \") print(a) Complete the Python program by writing code where the # more code goes here comment is found so that the desired output is produced. See if you can do it by only using assignment statements and variables, without using any new string values. (Hint: you’ll need to create a least one new variable!)\nAnswer 1.6 Answer One possible answer is given below:\na = \"abba\" b = \"banana\" c = \"bandana\" # more code goes here temp = a a = c c = temp print(c, end=\" \") print(b, end=\" \") print(a) This problem demonstrates the typical process for swapping variables!\n",
    "description": "",
    "tags": null,
    "title": "Variables Practice",
    "uri": "/01-basic-python/08-variables-practice/"
  },
  {
    "content": "Let’s try some simple practice problems. These problems are not graded - they are just for you to practice before doing the real exercises in the lab itself. You can find the answers below each question by clicking the button below each question.\n4.5 Reading Code Consider the following Python program:\na = int(input(\"Enter a whole number: \")) b = int(input(\"Enter a whole number: \")) if (a + b) % 3 == 0: print(\"Branch 1\") else: print(\"Branch 2\") a = a * 2 b = b * 3 if (a + b) % 3 == 0: print(\"Branch 3\") else: print(\"Branch 4\") What output is printed when the user inputs the values $ 2 $ and $ 4 $?\nAnswer 4.5 Answer This program will produce the following output:\nBranch 1 Branch 4 This is because $ 2 + 4 \\text{ % } 3 == 0 $ is True, but $ 4 + 12 \\text{ % } 3 == 0 $ is False.\n4.6 Testing Code Consider the program in the previous question. Write a set of possible inputs to the program that will achieve path coverage. For each set of inputs, identify which branches will be executed when that input is provided to the program.\nThink carefully! The same if statement is executed twice with different values, but those values are related to each other.\nAnswer 4.6 Answer To achieve path coverage, the following inputs can be used:\n3 and 3 - Branch 1 \u0026 3 2 and 4 - Branch 1 \u0026 4 3 and 2 - Branch 2 \u0026 3 2 and 2 - Branch 2 \u0026 4 There are many other possible answers to this question!\n4.7 Reading Code Consider the following Python program:\nx = int(input(\"Enter an integer: \")) y = int(input(\"Enter an integer: \")) if x * 5 \u003e y: print(\"Branch 1\") else: print(\"Branch 2\") if y % 5 == x: print(\"Branch 3\") else: print(\"Branch 4\") What output is displayed when the user inputs the values $ 4 $ and $ 29 $?\nAnswer 4.7 Answer The program will produce this output:\nBranch 2 Branch 3 This is because $ 4 * 5 \u003e 29 $ is False, but $ 29 % 5 = 4 $ is True.\n4.8 Testing Code Consider the program in the previous question. Write a set of possible inputs to the program that will achieve path coverage. For each set of inputs, identify which branches will be executed when that input is provided to the program.\nAnswer 4.8 Answer To achieve path coverage, the following inputs can be used:\n3 and 13 - Branches 1 \u0026 3 4 and 13 - Branches 1 \u0026 4 4 and 29 - Branches 2 \u0026 3 4 and 30 - Branches 2 \u0026 4 There are many other possible answers to this question!\n4.9 Writing Code Write a complete Python that performs the following actions:\nAccept a single input from the user and convert it to an integer If the number is even, display “That is an even number”. If it is odd, display “That is an odd number”. If the number is negative, display “That is a negative number”. If it is zero or positive, display “That is a positive number”. Your program should include at least two conditional statements.\nAnswer 4.9 Answer One possible answer is given below:\nx = int(input(\"Enter an integer: \")) if x % 2 == 0: print(\"That is an even number\") else: print(\"that is an odd number\") if x \u003c 0: print(\"That is a negative number\") else: print(\"That is a positive number\") 4.10 Writing Code Write a complete Python program in that file that performs the following actions:\nAccept a single string as input from the user If the string comes before the string “First” in lexicographic order, print “That comes before First”. If not, print “That comes after First”. If the string comes after the string “last” in lexicographic order, print “That comes after last”. If not, print “That comes before last”. Recall that you can use Boolean comparators such as \u003c and \u003e to compare two strings in Python. Also, pay special attention to the capitalization of the words “First” and “last” in the description above.\nYour program should include at least two conditional statements.\nBonus food for thought: look at your completed answer - is there a path that is not possible to actually test? Why is that?\nAnswer 4.10 Answer One possible answer is given below:\ns = input(\"Enter a string: \") if s \u003c \"First\": print(\"That comes before First\") else: print(\"That comes after First\") if s \u003e \"last\": print(\"That comes after last\") else: print(\"That comes before last\") Notice that it is impossible to provide an input that will come before the string \"First\" and after the string \"last\" - therefore one of the four possible paths in this program is impossible to test. In a future lab, we’ll see how we can combine these statements in a way that they won’t include any impossible paths.\n",
    "description": "",
    "tags": null,
    "title": "Conditionals Practice",
    "uri": "/04-conditionals/09-conditionals-practice/"
  },
  {
    "content": " Resources Slides For loops can also be nested, just like while loops. In fact, nesting for loops is often much simpler than nesting while loops, since it is very easy to predict exactly how many times a for loop will iterate, and also because it is generally easier to determine if a for loop will properly terminate instead of a while loop.\nA great way to explore using nested for loops is by printing ASCII Art shapes. For example, consider the following Python program that contains nested for loops:\nfor i in range(3): for j in range(5): print(\"* \", end=\"\") print(\"\") Just by looking at the code, can you predict what shape it will print? We can check the result by running the program on the terminal directly. If we do so, we should receive this output:\n* * * * * * * * * * * * * * * It printed a rectangle that is $ 3 $ rows tall (the outer for loop) and $ 5 $ columns wide (the inner for loop). If we look back at our code, this hopefully becomes very clear. This is a very typical structure for nested for loops - the innermost loop will handle printing one line of data, and then the outer for loop is used to determine the number of lines that will be printed.\nThe process for dealing with nested for loops is nearly identical to nested while loops. So, we won’t go through a full example using Python Tutor. However, feel free to run any of the examples in this lab in Python Tutor yourself and make sure you clearly understand how it works and can easily predict the output based on a few changes.\nExample 1 Let’s look at a few more examples of nested for loops and see if we can predict the shape that is created when we run the code.\nfor i in range(5): for j in range(i + 1): print(\"* \", end=\"\") print(\"\") This time, we’ve updated the inner for loop to use range(i + 1), so each time that inner loop is reached, the range will be different based on the current value of i from the outer loop. So, we can assume that each line of text will be a different size. See if you can figure out what shape this will print!\nWhen we run the code, we’ll get this output:\n* * * * * * * * * * * * * * * We see a triangle that is $ 5 $ lines tall and $ 5 $ columns wide. If we look at the code, we know that we’ll have 5 rows of output based on the range(5) used in the outer loop. Then, in the inner loop, we can see that the first time through we’ll only have a single item, since i is $ 0 $ and the range used is range(i + 1).\nThe next iteration of the outer loop will have $ 1 $ stored in i, so we’ll end up repeating the inner loop $ 2 $, or i + 1, times. We’ll repeat that process until the final line, which will have $ 5 $ characters in it to complete the triangle.\nFrom here, we can quickly modify the program to change the structure of the triangle. For example, to flip the triangle and make it point downward, we can change the range in the inner loop to range(i, 5) instead!\nExample 2 What if we want to flip the triangle along the vertical axis, so that the long side runs from the top-right to the bottom-left? How can we change our nested loops to achieve that outcome?\nIn that case, we’ll not only have to print the correct number of asterisks, but we’ll also need to print the correct number of spaces on each line, before the asterisks. One possible way to achieve this is shown in this code:\nfor i in range(5): for j in range(4 - i): print(\" \", end=\"\") for j in range(i + 1): print(\"* \", end=\"\") print(\"\") Here, we have two for loops nested inside of our outer loop. The first loop creates a range using the expression 4 - i, and the second loop uses the expression i + i. So, when i is equal to $ 0 $ during the first iteration of the outer loop, the first inner loop will be executed $ 4 $ times, and the second loop only $ 1 $ time. Then, on the next iteration of the outer loop, the first inner loop will only run $ 3 $ times, while the second loop now runs $ 2 $ times. Each time, the sum of the iterations will be $ 5 $, so our lines will always be the same length.\nWhen we run the code, we’ll get this output:\n* * * * * * * * * * * * * * * Example 3 Up to this point, we’ve just been writing loops to print shapes using ASCII art. While that may seem trivial, understanding the “shape” that will be produced by a given set of nested loops can really help us understand how the code itself will function with other data.\nConsider this example code:\ntotal = 0 count = 0 for i in range(10): for j in range(i + 1): total = total + (i * j) count += 1 print(f\"sum: {total}, count: {count}\") main() Before we even try to run this code, can we guess what the final value of the count variable will be? Put another way, can we determine how many times we’ll execute the code in the innermost loop, which will help us understand how long it will take for this program to run?\nLet’s compare this code to the first example shown above:\nfor i in range(5): for j in range(i + 1): print(\"* \", end=\"\") print(\"\") Notice how the code structure is very similar? The outermost loop runs a given number of times, and then the inner loop’s iterations are determined by the value of the outer loop’s iterator variable. Since we know that the first example produces a triangle, we can guess that the program above runs in a similar way. So, the first iteration of the outer loop will run the inner loop once, then twice on the second iteration, and so on, all the way up to $ 10 $ iterations. If we sum up all the numbers from $ 1 $ to $ 10 $, we get $ 55 $.\nNow let’s run that code and see if we are correct:\nAs this example shows, we can use our basic understanding of various looping structures to help us understand more complex programs, and even predict their output without running or tracing the program. This is a very useful skill to learn when working with nested loops.\n",
    "description": "",
    "tags": null,
    "title": "Nested For Loops",
    "uri": "/05-loops/09-nested-for/"
  },
  {
    "content": "Python We introduced some basic statements and structures in the Python programming language. Let’s quickly review them!\nPrint Statement The print(expression) statement is used to print output on the terminal.\nIt will evaluate expression to a value, then display it to the screen. By default, it will add a newline to the end of the output. We can change that using the end parameter, such as print(expression, end=\"\") to remove the newline. Assignment Statement The assignment statement, like a = expression is used to create variables and store values in the variables.\nThe variable must be on the left side, and the right side must be an expression that evaluates to a single value. If the variable does not exist, it is created. Otherwise, the current value of the variable is replaced by the new value. Variable names must begin with a letter or underscore, and may only contain letters, numbers, and underscores. Variable names beginning with an underscore have a special meaning, so we won’t use them right now. ",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/01-basic-python/09-summary/"
  },
  {
    "content": "In this lab, we covered several major important topics. Let’s quickly review them.\nData Types in Python str data type stores text (strings). Use str(expression) to convert an expression to a string if possible. int data type stores whole numbers (integers). Use int(expression) to convert an expression to an integer if possible. float data type stored decimal numbers (floating-point). Use float(expression) to convert an expression to a floating-point value, if possible. Math Operators in Python + Addition - Subtraction * Multiplication ** Exponentiation (Power) / Division // Integer Division % Modulo (the remainder of division) Python Order of operations Parentheses Exponentiation Multiplication, Division, Integer Division, and Modulo from left to right Addition and Subtraction from left to right ",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/02-numbers/09-summary/"
  },
  {
    "content": " Resources Slides Conditional statements are a very powerful tool for programmers to use. So far in this lab, we’ve explored simple conditional statements, including the if statement and if-else statement in Python. However, up to this point we’ve only looked at how we can use a single conditional statement at a time in a program, which can be very limiting. Now we’re going to explore how we can combine conditional statements in a variety of different ways to build even more complex programs. These combined, or nested conditional statements, are commonly used across all programming languages, but learning how to build and debug them takes time and practice. We’ll work through several examples, and then you’ll get a chance to try it yourself.\nLinear Conditional Statements To explore the various ways we can use conditional statements in code, let’s start by examining the same problem using three different techniques. We’ll use the classic Rock Paper Scissors game. In this game, two players simultaneously make one of three hand gestures, and then determine a winner based on the following diagram:\n1\nFor example, if the first player displays a balled fist, representing rock and the second player displays a flat hand, representing paper, then the second player wins because “paper covers rock” according to the rules. If the players both display the same symbol, the game is considered a tie.\nSo, to make this work, we’re going to write a Python program that reads two inputs representing the symbols, and then we’ll use some conditional statements to determine which player wins. A basic skeleton of this program is shown below:\np1 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 1: \") p2 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 2: \") # determine the winner Our goal, therefore, is to replace the comment # determine the winner with a set of conditional statements and print statements to accomplish this goal.\nLinear Conditional Statements First, let’s try to write this program using what we already know. We’ve already learned how to use conditional statements, and it is completely possible to write this program using just a set of linear conditional statements and nothing else. So, to do this, we need to determine each possible combination of inputs, and then write an if statement for each one. Since there are $ 3 $ possible inputs for each player, we know there are $ 3 * 3 = 9 $ possible combinations:\nPlayer 1 Player 2 Output rock rock tie rock paper player 2 wins rock scissors player 1 wins paper rock player 1 wins paper paper tie paper scissors player 2 wins scissors rock player 2 wins scissors paper player 1 wins scissors scissors tie We also have to deal with a final option where one player or the other inputs an invalid value. So, in total, we’ll have $ 10 $ conditional statements in our program!\nLet’s first try to make a quick flowchart of this program. Since we need $ 10 $ conditional statements, our flowchart will have $ 10 $ of the diamond-shaped decision nodes. Unfortunately, that would make a very large flowchart, so we’ll only include the first three decision nodes in the flowchart shown here:\nAs we can see, this flowchart is very tall, and just consists of one decision node after another. Thankfully, we should know how to implement this in code based on what we’ve previously learned. Below is a full implementation of this program in Python, using just linear conditional statements:\np1 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 1: \") p2 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 2: \") if p1 == \"rock\" and p2 == \"rock\": print(\"tie\") if p1 == \"rock\" and p2 == \"paper\": print(\"player 2 wins\") if p1 == \"rock\" and p2 == \"scissors\": print(\"player 1 wins\") if p1 == \"paper\" and p2 == \"rock\": print(\"player 1 wins\") if p1 == \"paper\" and p2 == \"paper\": print(\"tie\") if p1 == \"paper\" and p2 == \"scissors\": print(\"player 2 wins\") if p1 == \"scissors\" and p2 == \"rock\": print(\"player 2 wins\") if p1 == \"scissors\" and p2 == \"paper\": print(\"player 1 wins\") if p1 == \"scissors\" and p2 == \"scissors\": print(\"tie\") if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") or not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") This program seems a bit complex, but if we step through it one step at a time it should be easy to follow. For example, if the user inputs \"scissors\" for player 1 and \"rock\" for player 2, we just have to find the conditional statement that matches that input and print the correct output. Since we were careful about how we wrote the Boolean expressions for these conditional statements, we know that it is only possible for one of them to evaluate to true. So, we’d say that those Boolean expressions are mutually exclusive, since it is impossible for two of them to be true at the same time.\nThings get a bit more difficult in the last conditional statement. Here, we want to make sure the user has not input an invalid value for either player. Unfortunately, the only way to do that using linear conditional statements is to explicitly check each possible value and make sure that the user did not input that value. This can seem pretty redundant, and it indeed is! As we’ll see later in this lab, there are better ways we can structure this program to avoid having to explicitly list all possible inputs when checking for an invalid one.\nBefore moving on, it is always a good idea to run this code yourself, either directly in Python or using Python Tutor, to make sure you understand how it works and what it does.\nAlternative Version There is an alternative way we can write this program using linear if statements. Instead of having an if statement for each possible combination of inputs, we can instead have a single if statement for each possible output, and construct more complex Boolean expressions that are used in each if statement. Here’s what that would look like in Python:\np1 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 1: \") p2 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 2: \") if (p1 == \"rock\" and p2 == \"rock\") or (p1 == \"paper\" and p2 == \"paper\") or (p1 == \"scissors\" and p2 == \"scissors\"): print(\"tie\") if (p1 == \"rock\" and p2 == \"paper\") or (p1 == \"paper\" and p2 == \"scissors\") or (p1 == \"scissors\" and p2 == \"rock\"): print(\"player 2 wins\") if (p1 == \"rock\" and p2 == \"scissors\") or (p1 == \"paper\" and p2 == \"rock\") or (p1 == \"scissors\" and p2 == \"paper\"): print(\"player 1 wins\") if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") or not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") In this example, we now have just four if statements, but each one now requires a Boolean expression that includes multiple parts. So, this program is simultaneously more and less complex than the previous example. It has fewer lines of code, but each line can be much trickier to understand and debug.\nAgain, feel free to run this code in either Python Tutor or directly in Python to confirm that it works and make sure you understand it before continuing.\nIn terms of style, both of these options are pretty much equivalent - there’s no reason to choose one over the other. However, we’ll see later in this lab, there are much better ways we can write this program using chaining and nesting with conditional statements.\nPEP 8 and Pythno Style The Python programming language has its own style guide, known as “PEP 8” to most Python programmers. One of the major conventions proposed in that guide is limiting the length of each line of code to just 79 characters, in order to make the code more readable. However, as we’ve seen above, it is very easy to exceed that length when dealing with complex Boolean expressions, and we’ll see this again as we add multiple levels of indentation when we nest conditional statements.\nIn this course, we won’t worry about line length, even though some text editors may mark those lines as being incorrect in Python. Likewise, in many examples we won’t wrap the lines to a shorter length, except for readability purposes in the videos and slides.\nThat said, it’s definitely a good style to try and follow, and we encourage you to think about ways you can write your code to keep it as concise and readable as possible. Having shorter lines of code, while still using descriptive variable and function names, is a good start!\nFile:Rock-paper-scissors.svg. (2020, November 18). Wikimedia Commons, the free media repository. Retrieved 16:57, February 28, 2022 from https://commons.wikimedia.org/w/index.php?title=File:Rock-paper-scissors.svg\u0026oldid=513212597. ↩︎\n",
    "description": "",
    "tags": null,
    "title": "Linear Conditionals",
    "uri": "/04-conditionals/10-linear/"
  },
  {
    "content": " Resources Slides Testing nested loops can also be very tricky, especially because they can make our program’s control flow even more complex. So, let’s briefly go through an example to see how to determine what inputs we can use to test nested loops.\nConsider the following example program:\nx = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) y = int(input(\"Enter a positive integer: \")) while y \u003c= 0: print(\"Invalid input!\") y = int(input(\"Enter a positive integer: \")) while y \u003c= x: for i in range(x - y): print(\"*\", end=\"\") y = y + 2 print(\"\") print(\"Complete!\") Let’s work through the process of generating some test cases for this program to see if it runs without any errors. As always, our biggest concern is to make sure that we don’t reach a situation where the program enters an infinite loop, and that we also try to provide inputs that will enter each loop at least once, and also bypass each loop if possible.\nInput Loop First, we see that the code uses a loop twice to make sure the user inputs only positive values. So, some of our first test cases could involve trying values such as $ -1 $, $ 0 $ and $ 1 $ to check the edge cases of that while loop’s Boolean expression. When we run the program and provide those inputs, we should see it enter the loop in that function at least once.\nWe can also bypass that loop by simply making sure we enter a positive integer each time. So, we know we have a few test cases available that will achieve branch coverage for that loop.\nOuter While Loop Next, let’s consider the outermost while loop after the input loops. That loop uses the Boolean expression y \u003c= x to determine if the loop should be entered or not. So, we want to come up with a few tests that check the edge cases of that Boolean expression. We can start by choosing a value to use for x, such as $ 5 $. Then, the edge cases of that Boolean expression would be when y is either $ 4 $, $ 5 $, or $ 6 $.\nIf y is $ 6 $, the Boolean expression would be False and it should bypass the loop. We can easily test this to make sure that is the case:\nLikewise, if y is $ 4 $, we know that it should enter the outermost loop. Inside, we see a for loop that will iterate based on the expression x - y. Effectively, it will compute the difference between x and y and then iterate that many times. So, if x is $ 4 $ and y is $ 5 $, the difference between those values will be $ 1 $. So, we’ll enter the innermost for loop at least once. When we run the program with these inputs, we’ll see the following output:\nWhat if we set both x and y to be the same value? We know that the inner for loop will run x - y times, so if both x and y are the same value, this would be a way to bypass that loop, while still entering the outermost while loop since y \u003c= x will be True. However, when we try to run the program with these inputs, we’ll see something interesting happen:\nOur program will quickly start printing blank lines of output to the terminal. So quickly, in fact, that it is hard to even see what happens. As it turns out, we accidentally caused our program to enter an infinite loop! When this happens, the only way to stop the program is to close the terminal window it is running in, or use the CTRL+C keyboard command to interrupt it. So, let’s see why this infinite loop is occurring, and figure out how we can fix it.\nInfinite Loop Did you spot the infinite loop when you first read the program’s code? It can be really tricky to find, which is why we have to be very good about choosing test cases that will explore many different ways to run the program.\nIn this case, the infinite loop is caused by the interaction between the two loops. In the outermost while loop, we have the Boolean expression y \u003c= x to enter the loop. However, inside that loop, the for loop will only execute x - y times, which also happens to be the loop variant for the outer while loop. The key to the infinite loop lies in the fact that the only line inside of the outer while loop that will change the value of either x or y is also inside of the inner for loop. So, if we don’t execute the for loop’s code at all, then the value of x and y won’t change either, and we’ll continually repeat the steps of the outermost while loop.\nThere are many ways to fix this problem, but the simplest would be to change the Boolean expression of the outermost while loop to be y \u003c x. That will ensure that there is at least one iteration of the innermost for loop, and the infinite loop condition will be avoided.\nSo, as this example shows, testing nested loops is just like testing regular loops - we want to try and find inputs that will enter the loop at least once, as well as inputs that will bypass the loops if possible, just to make sure there aren’t any strange situations that may arise. While this won’t find all errors that are present in code containing nested loops, it is a great way to start testing your programs.\n",
    "description": "",
    "tags": null,
    "title": "Testing Nested Loops",
    "uri": "/05-loops/10-testing-nested/"
  },
  {
    "content": " Resources Slides In the previous example, we saw a set of linear if statements to represent a Rock Paper Scissors game. As we discussed on that page, the Boolean expressions are meant to be mutually exclusive, meaning that only one of the Boolean expressions will be true no matter what input the user provides.\nWhen we have mutually exclusive Boolean expressions like this, we can instead use if-else statements to make the mutually exclusive structure of the program clearer to the user. Let’s see how we can do that.\nChaining Conditional Statements To chain conditional statements, we can simply place the next conditional statement on the False branch of the first statement. This means that, if the first Boolean expression is True, we’ll execute the True branch, and then jump to the end of the entire statement. If it is False, then we’ll go to the False branch and try the next conditional statement. Here’s what this would look like in a flowchart:\nThis flowchart is indeed very similar to the previous one, but with one major change. Now, if any one of the Boolean expressions evaluates to True, that branch will be executed and then the control flow will immediately drop all the way to the end of the program, without ever testing any of the other Boolean expressions. This means that, overall, this program will be a bit more efficient than the one with linear conditional statements, because on average it will only have to try half of them before the program ends.\nNow let’s take a look at what this program would look like in Python:\np1 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 1: \") p2 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 2: \") if p1 == \"rock\" and p2 == \"rock\": print(\"tie\") else: if p1 == \"rock\" and p2 == \"paper\": print(\"player 2 wins\") else: if p1 == \"rock\" and p2 == \"scissors\": print(\"player 1 wins\") else: if p1 == \"paper\" and p2 == \"rock\": print(\"player 1 wins\") else: if p1 == \"paper\" and p2 == \"paper\": print(\"tie\") else: if p1 == \"paper\" and p2 == \"scissors\": print(\"player 2 wins\") else: if p1 == \"scissors\" and p2 == \"rock\": print(\"player 2 wins\") else: if p1 == \"scissors\" and p2 == \"paper\": print(\"player 1 wins\") else: if p1 == \"scissors\" and p2 == \"scissors\": print(\"tie\") else: if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") or not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") As we can see, this program is basically the same code as the previous program, but with the addition of a number of else keywords to place each subsequent conditional statement into the False branch of the previous one. In addition, since Python requires us to add a level of indentation for each conditional statement, we see that this program very quickly becomes difficult to read. In fact, the last Boolean expression is so long that it doesn’t even fit well on the screen!\nWe can make a similar change to the other example on the previous page:\np1 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 1: \") p2 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 2: \") if (p1 == \"rock\" and p2 == \"rock\") or (p1 == \"paper\" and p2 == \"paper\") or (p1 == \"scissors\" and p2 == \"scissors\"): print(\"tie\") else: if (p1 == \"rock\" and p2 == \"paper\") or (p1 == \"paper\" and p2 == \"scissors\") or (p1 == \"scissors\" and p2 == \"rock\"): print(\"player 2 wins\") else: if (p1 == \"rock\" and p2 == \"scissors\") or (p1 == \"paper\" and p2 == \"rock\") or (p1 == \"scissors\" and p2 == \"paper\"): print(\"player 1 wins\") else: if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") or not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") Again, this results in very long lines of code, but it still makes it easy to see that the program is built in the style of mutual exclusion, and only one of the True branches will be executed. As before, feel free to run these programs directly in Python or using Python Tutor to confirm they work and that you understand how they work before continuing.\nThe Final Case Now that we’ve built a program structure that enforces mutual exclusion, we’ll might notice something really interesting - the final if statement is no longer required! This is because we’ve already exhausted all other possible situations, so the only possible case is the last one. In that case, we can remove that entire statement and just replace it with the code from the True branch. Here’s what that would look like in Python:\np1 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 1: \") p2 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 2: \") if p1 == \"rock\" and p2 == \"rock\": print(\"tie\") else: if p1 == \"rock\" and p2 == \"paper\": print(\"player 2 wins\") else: if p1 == \"rock\" and p2 == \"scissors\": print(\"player 1 wins\") else: if p1 == \"paper\" and p2 == \"rock\": print(\"player 1 wins\") else: if p1 == \"paper\" and p2 == \"paper\": print(\"tie\") else: if p1 == \"paper\" and p2 == \"scissors\": print(\"player 2 wins\") else: if p1 == \"scissors\" and p2 == \"rock\": print(\"player 2 wins\") else: if p1 == \"scissors\" and p2 == \"paper\": print(\"player 1 wins\") else: if p1 == \"scissors\" and p2 == \"scissors\": print(\"tie\") else: # All other options have been checked print(\"error\") In this code, there is a comment showing where the previous if statement was placed, and now it simply prints an error. Again, this is possible because we’ve tried every possible valid combination of inputs in the previous Boolean expressions, so all that is left is invalid input. Try it yourself! See if you can come up with any valid input that isn’t already handled by the Boolean expressions - there shouldn’t be any of them.\nElif Keyword To help build programs that include chaining conditional statements, Python includes a special keyword elif for this exact situation. The elif keyword is a shortened version of else if, and it means to replace the situation where an if statement is directly placed inside of an else branch. So, when we are chaining conditional statements, we can now do so without adding additional levels of indentation.\nHere’s what the previous example looks like when we use the elif keyword in Python:\np1 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 1: \") p2 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 2: \") if p1 == \"rock\" and p2 == \"rock\": print(\"tie\") elif p1 == \"rock\" and p2 == \"paper\": print(\"player 2 wins\") elif p1 == \"rock\" and p2 == \"scissors\": print(\"player 1 wins\") elif p1 == \"paper\" and p2 == \"rock\": print(\"player 1 wins\") elif p1 == \"paper\" and p2 == \"paper\": print(\"tie\") elif p1 == \"paper\" and p2 == \"scissors\": print(\"player 2 wins\") elif p1 == \"scissors\" and p2 == \"rock\": print(\"player 2 wins\") elif p1 == \"scissors\" and p2 == \"paper\": print(\"player 1 wins\") elif p1 == \"scissors\" and p2 == \"scissors\": print(\"tie\") else: # All other options have been checked print(\"error\") There we go! That’s much easier to read, and in fact it is much closer to the examples of linear conditionals on the previous page. This is the exact same program as before, but now it is super clear that we are dealing with a mutually exclusive set of Boolean expressions. And, we can still have a single else branch at the very end that will be executed if none of the Boolean expressions evaluates to True.\nA structure of mutually exclusive statements like this is very commonly used in programming, and Python makes it very simple to build using the elif keyword.\nError Condition First Using chained conditional statements like this makes it easy to detect and handle errors in the final else block, since all other options have already been checked. However, some programmers prefer to explicitly check for errors in the input at the start of the code, before any other work is done. This is especially common when working with loops to prompt the user for new input in case of an error, which we’ll learn about in a later lab.\nWhen you are reading code, it is important to check both the start and end of a block of code when looking for possible error checks, since they could be included in either place. Recognizing common coding styles and conventions such as where to check for errors will help us better understand code written by others, and also make our code more readable by others.\n",
    "description": "",
    "tags": null,
    "title": "Chaining Conditionals",
    "uri": "/04-conditionals/11-chaining/"
  },
  {
    "content": " Resources Slides Now that we’ve explored how to create programs that contain nested loops, let’s work through a complete example problem to see how we can convert a problem statement into working code.\nConsider the following problem statement:\nWrite a program to print the sum of the first n prime numbers, where n is provided as input from the user.\nThis is a very simple problem statement, but it can be very complex to build a program that satisfies it. So, let’s go through the steps and see if we can get it to work.\nHandling User Input The first thing we’ll need to do is get input from the user, since we really can’t do anything else until we know what our goal is. While the problem statement doesn’t include any information about what inputs are acceptable, we can infer that only positive integers should be used as input. So, we can borrow the loop for input from earlier in this module to handle all of our input:\nx = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) n = x Reusing existing code, such as the loop for input we just included here, is a great way to build our programs. We can always think of previous code that we’ve already written and tested as possible building blocks for future programs, and reusing existing code is a great way to speed up our development process.\nPrime Numbers Next, we need some way to determine if a number is a prime number. Recall from mathematics that a prime number is a number that is only equally divisible by $ 1 $ and itself. For example, $ 7 $ is prime, but $ 8 $ is not since it can be evenly divided by $ 4 $.\nThankfully, we know that we can use the modulo operator % to determine if a number if evenly divisible by another number. So, all we need to do is check if each number less than our chosen number can equally divide it. If none of them can, then our chosen number is prime.\nSo, let’s write code that performs this operation. We know that we need to check all of the numbers from $ 2 $ up to but not including x. We can do this using a for loop and the range() function:\nfor i in range(2, x): Inside of the for loop, we want to check and see if the iterator variable i can evenly divide the chosen number n using the modulo operator:\nfor i in range(2, x): if x % i == 0: # i equally divides x Here’s where things get a bit tricky - if i can equally divide x, we know that x is not prime. So, let’s add a Boolean value to keep track of this. We’ll set it initially to True before the loop, and then we can set it to False as soon as we know the number is not prime:\nis_prime = True for i in range(2, x): if x % i == 0: is_prime = False # what if we get here? Break Statement We might realize that we don’t have to check any other values once we have determined that x is not prime. So, in our code, we can just use the break statement to end the loop early and go to the next part of the code. In effect, we can use this to shortcut the rest of the loop.\nis_prime = True for i in range(2, x): if x % i == 0: is_prime = False break # what if we get here? We don’t introduce the break and continue statements in this class just to simplify things, but you are welcome to use them if you understand them.\nHowever, what happens if we check all of the values from $ 2 $ up to x and don’t find a single one that will equally divide our chosen number x? In that case, we’ll reach the end of our for loop, and is_prime will still be True. So, we’ve confirmed that x is indeed a prime number!\nis_prime = True for i in range(2, x): if x % i == 0: is_prime = False # is_prime stores whether nx is prime or not There we go! That’s a quick and easy way to determine if a given number is prime. This is a great example of a pattern that we’ll see many times as we write complex programs whenever we must determine if a particular situation is true for a given list of numbers. Inside of the loop, we’ll check each case and set a value to False if it isn’t true. If it is true, then we’ll complete the entire loop without setting that value to False, so we’ll know that it is True at the end of the code. We’ll see this pattern again in a later lab.\nEfficient Prime Numbers The code above is very simple, but not very efficient. With a bit of thought, it is easy to determine that we only have to actually check numbers up to x /2, since it is impossible for any number larger than that to evenly divide x. Likewise, we can do some quick math to eliminate numbers that end in an even digit or $ 5 $, since those numbers will never be prime.\nFinally, we could use a more advanced mathematical technique such as the Sieve of Eratosthenes to generate all prime numbers more quickly. However, for this example, we’ll stick to the simplest approach.\nComplete Program Finally, now that we have the code to determine if a number is prime, we can complete our program by simply iterating through all possible numbers until we’ve found n prime numbers, and then print the sum:\nx = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) n = x count = 0 x = 2 total = 0 while count \u003c n: is_prime = True for i in range(2, x): if x % i == 0: is_prime = False if is_prime: total = total + x count = count + 1 x = x + 1 print(f\"The sum of the first {n} prime numbers is {total}\") This program requires three additional variables. The variable count is used to keep track of the number of prime numbers found, so we’ll increment it inside of the if statement each time we find a prime number. Likewise, the total variable keeps track of the sum of the prime numbers, which we’ll print at the end. Finally, we use x as our iterator variable, so we must make sure that we increment x each time the while loop iterates, outside of the if statement. We’ll start x at $ 2 $, since $ 1 $ is not a prime number mathematically. A very common programming mistake is to forget to increment x outside the if statement, resulting in an infinite loop. Also, we chose to use a while loop instead of a for loop since our program’s goal is to sum up the first n prime numbers, which is better expressed as a while loop instead of a for loop.\nFeel free to run this program in Python or using Python Tutor to confirm that it works as expected before continuing.\nTesting Testing this program is a bit complex, since we can only provide a single input. We can easily provide a negative value or $ 0 $ to confirm that the loop handling input is working correctly, but beyond that we have little control over the rest of the program just by changing inputs.\nInstead, we have to rely on our ability to read and analyze the code to determine if it is working properly. For example, we can look at the second loop in the main part of the code. It is a while loop, which relies on the count variable increasing until it is greater than or equal to n before it will terminate. We can see that count will be incremented each time the value of x is prime, so as long as we are able to find enough prime numbers, and assuming our code to check prime numbers works correctly, this loop should eventually terminate.\nIn the code to check if a number is prime, we have a simple for loop, which will always terminate eventually. There is no way to bypass it, so we don’t really have to worry about that code not eventually terminating.\nHowever, proving that this program creates the correct answer is a bit trickier. One of the best ways to do this is to simply check a few answers manually. For example, with a bit of searching online, we can find a list of prime numbers. According to Wikipedia, the first 9 prime numbers are:\n2 3 5 7 11 13 17 19 23 The sum of those numbers is easy to calculate using a calculator or other device, and eventually we can be fairly certain that the correct answer is $ 100 $. When we run our program, we should hopefully get the same result:\nWe can test a few other numbers until we are sure that our program is working correctly.\nHopefully this example is a good look at how to build a program using loops that meets a given problem description. We were able to put together various types of loops and conditional statements in our program, and then test it to be sure it works. As you continue to work on projects in this class, feel free to refer back to these examples for ideas and blocks of code that you may want to use in your own programs. Good luck!\n",
    "description": "",
    "tags": null,
    "title": "Worked Example",
    "uri": "/05-loops/11-example/"
  },
  {
    "content": " Resources Slides We’ve already seen how we can chain conditional statements by placing a new conditional statement inside of the False branch of another conditional statement. If we think about that, however, that implies that we probably should be able to place conditional statements inside of the True branch as well, or really anywhere. As it turns out, that’s exactly correct. We call this nesting, and it is really quite similar to what we’ve already seen in this lab.\nUsing nested conditional statements, we can really start to rethink the entire structure of our program and greatly simplify the code. Let’s take a look at how we can do that with our Rock Paper Scissors game.\nNesting Conditional Statements In our Rock Paper Scissors game, we are really checking the value of two different variables, p1 and p2. In all of our previous attempts, we built complex Boolean expressions that checked the values of both variables in the same expression, such as p1 == \"rock\" and p2 == \"scissors\". What if we simply checked the value of one variable at a time, and then used nested conditional statements in place of the and operator? What would that look like?\nHere’s an example of a Rock Paper Scissors game that makes use of nested conditional statements:\nHere, we begin by checking if the value in p1 is \"rock\". If it is, then we’ll go to the True branch, and start checking the values of p2. If p2 is also \"rock\", then we know we have a tie and we can output that result. If not, we can check to see if it is \"paper\" or \"scissors\", and output the appropriate result. If none of those are found, then we have to output an error.\nIn the False branch of the first conditional statement, we know that p1 is not \"rock\", so we’ll have to check if it is \"paper\" and \"scissors\". Inside of each of those conditional statements, we’ll also have to check the value of p2, so we’ll end up with a significant number of conditional statements in total!\nLet’s see what such a program would look like in Python:\np1 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 1: \") p2 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 2: \") if p1 == \"rock\": if p2 == \"rock\": print(\"tie\") elif p2 == \"paper\": print(\"player 2 wins\") elif p2 == \"scissors\": print(\"player 1 wins\") else: print(\"error\") elif p1 == \"paper\": if p2 == \"rock\": print(\"player 1 wins\") elif p2 == \"paper\": print(\"tie\") elif p2 == \"scissors\": print(\"player 2 wins\") else: print(\"error\") elif p1 == \"scissors\": if p2 == \"rock\": print(\"player 2 wins\") elif p2 == \"paper\": print(\"player 1 wins\") elif p2 == \"scissors\": print(\"tie\") else: print(\"error\") else: print(\"error\") In this example, we have an outer set of chained conditional statements checking the value of p1, and then each of the branches will check the value of p2 and determine which output is correct. It is very similar in structure to the chained conditional example on the previous page, just laid out a bit differently. As before, try running this program yourself in either Python or Python Tutor to make sure it works and you understand how it is structured.\nRemoving Duplicate States Looking at this code, one thing we might quickly notice is that we now have four places that print \"error\" instead of just one. This is because we now have to check the values of p2 in three separate places, and can’t simply assume that the final else case in the outermost conditional statement is the only case where an error might be found.\nOne way we can simplify this code is by including a specific conditional statement just to check for any error situations, and handle those upfront before the rest of the code. So, we can rewrite this code as shown here to accomplish that:\np1 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 1: \") p2 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 2: \") if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") or not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") else: if p1 == \"rock\": if p2 == \"rock\": print(\"tie\") elif p2 == \"paper\": print(\"player 2 wins\") else: print(\"player 1 wins\") elif p1 == \"paper\": if p2 == \"rock\": print(\"player 1 wins\") elif p2 == \"paper\": print(\"tie\") else: print(\"player 2 wins\") else: if p2 == \"rock\": print(\"player 2 wins\") elif p2 == \"paper\": print(\"player 1 wins\") else: print(\"tie\") By confirming that both p1 and p2 only contain either \"rock\", \"paper\", or \"scissors\" first, we can then make some pretty handy assumptions later in our code. For example, now the outermost conditional statement only explicitly checks if p1 contains \"rock\" or \"paper\", and then the third block is simply an else clause by itself. We can do this because we already know that \"scissors\" is the only other possible value that can be stored in p1, so we don’t have to explicitly check for it. We can make similar changes to the nested conditional statements as well. So, just by adding one complex Boolean expression and conditional statement to our program, we were able to remove 4 that we no longer needed!\nFurther Simplification In fact, we can even take this one step further. Now that we know that both p1 and p2 only contain valid values, we can easily determine if that match has ended in a tie by simply checking if the variables contain the same value. So, with a bit of restructuring, we can simplify our program as shown here:\np1 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 1: \") p2 = input(\"Enter \\\"rock\\\", \\\"paper\\\", or \\\"scissors\\\" for player 2: \") if not (p1 == \"rock\" or p1 == \"paper\" or p1 == \"scissors\") or not (p2 == \"rock\" or p2 == \"paper\" or p2 == \"scissors\"): print(\"error\") else: if p1 == p2: print(\"tie\") elif p1 == \"rock\": if p2 == \"paper\": print(\"player 2 wins\") else: print(\"player 1 wins\") elif p1 == \"paper\": if p2 == \"rock\": print(\"player 1 wins\") else: print(\"player 2 wins\") else: if p2 == \"rock\": print(\"player 2 wins\") else: print(\"player 1 wins\") This code presents a clear, easy to read version of a Rock Paper Scissors program. At the top, we receive input from the users, and then the first conditional statement is used to determine if the input is valid. If not, it will print an error.\nIf the input is valid, then we can make some assumption about the various possible inputs in our program’s logic, which greatly reduced the number of conditional statements. We are also checking for ties at the beginning, so in the False branch of that conditional statement we can also assume that the values in p1 and p2 are different, further reducing the number of items we have to check.\nWe’ll revisit this example later in this course to show how we can convert the first conditional statement into a loop, which will prompt the user for new input if an invalid input is provided. This will make our program even better and easier for anyone to use.\n",
    "description": "",
    "tags": null,
    "title": "Nesting Conditionals",
    "uri": "/04-conditionals/12-nesting/"
  },
  {
    "content": "Let’s try some simple practice problems. These problems are not graded - they are just for you to practice before doing the real exercises in the lab itself. You can find the answers below each question by clicking the button below each question.\n5.7 Reading Code Consider the following Python program:\nx = int(input(\"Enter a positive integer: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer: \")) n = x for i in range(n - 1): for j in range(n - i - 1): print(\" \", end=\"\") for j in range(i + 1): print(\"* \", end=\"\") print(\"\") for i in range(n): for j in range(n): print(\"* \", end=\"\") print(\"\") Describe the shape that will be printed when this program is executed. Try to do so without running the code directly, but feel free to check your answer after guessing.\nAnswer 5.7 Answer This program will print a “house” shape, which is a square with a triangle on top. For example, if the user inputs $ 5 $, the output will be:\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 5.8 Debugging Code Consider the following Python program:\nx = 3 y = 5 while x =\u003e 0: for i in range(y): print(\"* \") print(\"\") x = x + 1 This code is supposed to print a rectangle of asterisks that is x rows tall and y columns wide. However, it contains multiple syntax and logic errors preventing it from working correctly. Describe how to fix the errors in the given code to produce the desired output.\nAnswer 5.8 Answer There are several errors:\nThe while loop uses =\u003e as a Boolean operator instead of \u003e The print() statement in the inner for loop should include the optional parameter end=\"\" to print all the asterisks on 1 line The line incrementing x should be decrementing x instead: x = x - 1 After making those changes, the code should be similar to:\nx = 3 y = 5 while x \u003e 0: for i in range(y): print(\"* \", end=\"\") print(\"\") x = x - 1 Other valid answers include changing the outer while loop into a for loop.\n5.9 Writing Code Write a complete Python program in that file that meets the specification below.\nWrite a program that will print a Parallelogram of asterisks that is m rows tall and n columns wide, where the topmost row is furthest toward the left. The values m and n should be provided by the user as input. If the user inputs a value that is $ 0 $ or negative, the program should print an error and prompt for input again.\nFor example, if the user inputs $ 3 $ and $ 5 $, the program should provide the following output:\n* * * * * * * * * * * * * * * Notice that each asterisk is separated by a space, and each successive row of the parallelogram begins one space to the right of the previous row.\nAnswer 5.9 Answer One possible solution is given below:\nx = int(input(\"Enter a positive integer for m: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer for m: \")) m = x x = int(input(\"Enter a positive integer for n: \")) while x \u003c= 0: print(\"Invalid input!\") x = int(input(\"Enter a positive integer for n: \")) n = x for i in range(m): for j in range(i): print(\" \", end=\"\") for j in range(n): print(\"* \", end=\"\") print(\"\") ",
    "description": "",
    "tags": null,
    "title": "Nesting Practice",
    "uri": "/05-loops/12-nesting-practice/"
  },
  {
    "content": " Resources Slides Now that we’ve seen how we can chain and nest multiple conditional statements in our code, we need to address a very important concept: variable scope.\nIn programming, variable scope refers to the locations in code where variables can be accessed. Contrary to what we may think based on our experience, when we declare a variable in our code, it may not always be available everywhere. Instead, we need to learn the rules that determine where variables are available and why.\nMany Languages: Block Scope Different Languages The example below demonstrates block scope, which is NOT how Python handles scope. We are using Python code so the example is understandable, but Python handles scope differently. See the next section for how Python actually handles scope.\nFirst, let’s talk about the most common type of variable scope, which is block scope. This type of variable scope is used in many programming languages, such as Java, C#, C/C++, and more. In block scope, variables are only available within the blocks where they are declared, including any other blocks nested within that block. Also, variables can only be accessed by code executed after the variable is initially declared or given a value.\nSo, what is a block? Effectively, each function and conditional statement introduces a new block in the program. In languages such as Java and C/C++, blocks are typically surrounded by curly braces {}. In Python, blocks are indicated by the level of indentation.\nFor example, consider the following Python code:\n# Global block x = int(input(\"Enter a number: \")) if x \u003e 5: # block A y = int(input(\"Enter a number: \")) if y \u003e 10: # block B z = 10 else: # block C z = 5 elif x \u003c 0: # block D a = -5 else: # block E b = 0 print(\"?\") This program contains six different blocks of code:\nThe Global block, which is all of the code at the top level of the file Block A, which is all of the code inside of the True branch of the outermost conditional statement. Block B, the True branch of the inner conditional statement Block C, the False branch of the inner conditional statement Block D, the True branch of the first elif clause of the outer conditional statement Block E, the False branch of the outermost conditional statement Inside of each of those blocks, we see various variables that are declared. For example, the variable x is declared in the Global block. So, with block scope, this means that the variable x is accessible anywhere inside of that block, including any blocks nested within it.\nBelow is a list of all of the variables in this program, annotated with the blocks where that variable is accessible in block scope:\nx - blocks Global, A, B, C, D, E y - blocks A, B, C z - blocks B and C more on this later a - block D b - block E One thing that is unique about this example is the variable z, which is declared in both block B and block C. What does this mean when we are dealing with block scope? Basically, those variables named z are actually two different variables! Since they cannot be accessed outside of the block that they are declared in, they should really be considered as completely separate entities, even though they are given the same name. This is one of the trickiest concepts when dealing with scope!\nSo, if this program is using block scope, what variables can be printed at the very end of the program, where the question mark ? is found in a print() statement? In this case, only the variable x exists in the Global block’s scope, so it is the only variable that we can print at the end of the program.\nIf we want to print the other variables, we must declare them in the appropriate scope. So, we can update our code as shown here to do that:\n# Global block # variable declarations in Global block y = 0 z = 0 a = 0 b = 0 x = int(input(\"Enter a number: \")) if x \u003e 5: # block A y = int(input(\"Enter a number: \")) if y \u003e 10: # block B z = 10 else: # block C z = 5 elif x \u003c 0: # block D a = -5 else: # block E b = 0 print(\"?\") With this change, we can now access all of the variables in the Global scope, so any one of them could be printed at the end of the program. This also has the side effect of making the variable z in both blocks B and C the same variable, since it is now declared at a higher scope.\nPython: Function Scope Python, however, uses a different type of variable scope known as function scope. In function scope, variables that are declared anywhere in a function are accessible everywhere in that function as soon as they’ve been declared or given a value. In Python, the Global scope is treated the same as a function’s scope, so variables declared in the Global scope in Python are accessible everywhere. So, once we see a variable in the code while we’re executing within a function or in the Global scope, we can access that variable anywhere within the same scope.\nPython Functions We haven’t introduced functions in Python quite yet, but it is important to go ahead and use the correct terminology here. For now, you can think of everything as being part of the “Global” function in Python. We’ll revisit this concept later when we introduce functions.\nLet’s go back to the previous example, and look at that in terms of function scope\n# Global block x = int(input(\"Enter a number: \")) if x \u003e 5: # block A y = int(input(\"Enter a number: \")) if y \u003e 10: # block B z = 10 else: # block C z = 5 elif x \u003c 0: # block D a = -5 else: # block E b = 0 print(\"?\") Using function scope, any of the variables x, y, z, a or b could be placed in the print() statement at the end of the code, and the program could work. However, there is one major caveat that we must keep in mind: we can only print the variable if it has been given a value in the program!\nFor example, if the user inputs a negative value for x, then the variables y, z, and b are never given a value! We can confirm this by running the program in Python Tutor. As we see here, at the end of the program, only the variables x and a are shown in the list of variables within the Global frame in Python Tutor on the right:\nBecause of this, we have to be careful when we write our programs in Python using function scope. It is very easy to find ourselves in situations where our program will work most of the time, since it usually executes the correct blocks of code to populate the variables we need, but there may be situations where that isn’t guaranteed.\nThis is where testing techniques such as path coverage are so important. If we have a set of inputs that achieve path coverage, and we are able to show that the variables we need are available at the end of the program in each of those paths, then we know that we can use them.\nAlternatively, we can build our programs in Python as if Python used block scope instead of function scope. By assuming that variables are only available in the blocks where they are given a value, we can always ensure that we won’t reach a situation where we are trying to access a variable that isn’t available. For novice programmers, this is often the simplest option.\nDealing with scope is a tricky part of learning to program. Thankfully, in Python, as well as many other languages, we can easily use tools such as Python Tutor and good testing techniques to make sure our programs are well written and won’t run into any errors related to variable scope.\n",
    "description": "",
    "tags": null,
    "title": "Blocks \u0026 Scope",
    "uri": "/04-conditionals/13-blocks-scope/"
  },
  {
    "content": "In this lab, we introduced several major important topics in Python. Let’s quickly review them.\nPython While Loops While loops in Python will execute while a Boolean expression evaluates to true.\nwhile \u003cboolean expression\u003e: \u003cblock of statements\u003e Range Function The range() function in Python is used to generate a list of numbers. It can be used in three ways:\nrange(stop) - numbers from $0$ up to (but not including) stop range(start, stop) - numbers from start up to (but not including) stop range(start, stop, step) - numbers from start up to (but not including) stop, with step between each number. Python For Loops For loops in Python will execute a set number of times.\nfor \u003citerator variable\u003e in \u003clist\u003e: \u003cblock of statements\u003e Input with Loops Loops can be used to request new input from the user if invalid input is received.\nx = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) while(x \u003c 0 or x \u003e 1): print(\"Invalid Input!\") x = float(input(\"Enter a percentage as a decimal number from 0 to 1: \")) Testing Loops Loops can be tested for both branch and path coverage. In general, achieving path coverage involves writing code that will enter the loop, and also code that will bypass the loop entirely.\nLoops should also be tested for termination and situations that may result in infinite loops. Using a loop variant and showing that it is monotonically decreasing is a helpful technique.\nNested Loops Loops in Python can be nested, just like any other statement. While loops and for loops can be nested in any combination.\nTesting Nested Loops When testing nested loops, it is important to consider situations where a loop will be executed and where it will be bypassed. It is also important to consider the loop variants for while loops to ensure that there aren’t situations where a loop will accidentally run infinitely.\nEfficiency Nested loops can result in programs that execute many individual steps, even using just a few lines of code. It is always helpful to think about the number of times a loop will execute and make sure that it isn’t executing more times than necessary.\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/05-loops/13-summary/"
  },
  {
    "content": " Resources Slides Let’s go through another worked example to see how we can translate a problem statement into a working program. We’ll also take a look at how we can test the program to verify that it is working as intended.\nProblem Statement Here’s a short and simple game that can be played by two players:\nThree players each guess a positive integer greater than $ 0 $, and then share them simultaneously. The winner is chosen following this formula:\nIf any two players have chosen the same number, the game is a tie. If all players have chosen even numbers, or all players have chosen odd numbers, then the smallest number wins. Otherwise, the largest number wins. This game has some similarities to Rock Paper Scissors, but the logic is quite a bit different. So, let’s work through how we would build this program using conditional statements.\nInitial Program Our first step should be to build a simple program that handles user input. So, we’ll create a new Python program that contains three variables to store user input. We’ll also use the input() function to read input, and the int() function to convert each input to an integer. Below that, we’ll add some print statements for testing. At this point, our program should look similar to this:\np1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) # debugging statements print(\"player 1 chose {}\".format(p1)) print(\"player 2 chose {}\".format(p2)) print(\"player 3 chose {}\".format(p3)) With this code in place, we’ve already created a Python program that we can run and test. So, before moving on, let’s run this program at least once to verify that it works correctly. This will help us quickly detect and correct any initial errors in our program, and make it much easer to debug logic errors later on.\nSo, when we run this program, we should see output similar to this:\nChecking for Valid Input Now that we have confirmed our program is working, let’s start writing the logic in this program. Deciding which conditional statement to write first is a very important step in designing a program, but it is difficult to learn what works best without lots of practice. If we look at the problem statement above, we see that there are several clear conditions that we’ll have to check:\nAre the numbers all even? If so, which number is smallest? Are the numbers all odd? If so, which number is smallest? Are the numbers not all even or odd? If so, which number is largest? However, there is one more condition that we should also keep in mind. This one isn’t clearly stated in the rules, but implied in the problem statement itself:\nAre all numbers greater than $ 0 $? So, to write an effective program, we should first make sure that all of the inputs are greater than $ 0 $. We can do this using a simple conditional statement. We’ll also remove our debugging statements, as they are no longer needed:\np1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") else: print(\"All numbers are greater than 0\") In this conditional statement, we are checking to see if any one of the numbers is less than or equal to $ 0 $. Of course, using some Boolean algebra and De Morgan’s law, we can see that this is equivalent to checking if all numbers are not greater than $ 0 $. Either approach is valid.\nChecking for Ties Once we know we have valid input, the next step in determining a winner is to first determine if there are any ties. For this, we simply need to check if any two players input the same number. Since there are three players, we need to have three different Boolean expressions to accomplish this. In our program, we could add a conditional statement as shown here:\np1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") elif p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") else: print(\"Not a Tie\") This is a pretty simple Boolean expression that will check and see if any possible pair of inputs is equal. We use the or Boolean operator here since any one of those can be true in order for the whole game to be a tie.\nAll Odds or Evens Next, let’s tackle whether the inputs are all odds or all evens. If we look at the rules above, this seems to be the next most logical thing we’ll need to know in order to determine the winner of the game. Recall that we can determine if a number is even or odd by using the modulo operator % and the number $ 2 $. If that result is $ 0 $, the number is even. If not, the number is odd.\nIn code, we can express that in a conditional statement as shown here:\np1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") elif p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") elif p1 % 2 == 0 and p2 % 2 == 0 and p3 % 2 == 0: print(\"All numbers are even\") elif p1 % 2 != 0 and p2 % 2 != 0 and p3 % 2 != 0: print(\"All numbers are odd\") else: print(\"Numbers are both even and odd\") Notice that we are using the and Boolean operator in these conditional statements, because we want to be sure that all numbers are either even or odd.\nIn this example, we’re also choosing to use chained conditional statements with the elif keyword instead of nesting the conditionals. This helps clearly show that each outcome is mutually exclusive from the other outcomes.\nHowever, we chose to nest the program logic inside of the outermost conditional statement, which checks for valid input. This helps us clearly see the part of the program that is determining who wins the game, and the part of the program that is validating the input. Later on, we’ll see how we can rewrite that conditional statement into a loop to prompt the user for new input, so it makes sense for us to keep it separate for now.\nDetermining the Smallest Number Once we know if the numbers are either all even or all odd, we know that the winning number is the smallest number of the three inputs. So, how can we determine which number is the smallest? We can use a couple of nested conditional statements!\nLet’s handle the situation where all numbers are even first. We know that the smallest number must be smaller than both other numbers. So, we can use a couple of Boolean expressions to check if that is the case for each number:\np1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") elif p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") elif p1 % 2 == 0 and p2 % 2 == 0 and p3 % 2 == 0: if p1 \u003c p2 and p1 \u003c p3: print(\"Player 1 wins\") elif p2 \u003c p1 and p2 \u003c p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") elif p1 % 2 != 0 and p2 % 2 != 0 and p3 % 2 != 0: print(\"All numbers are odd\") else: print(\"Numbers are both even and odd\") Here, we start by checking if player 1’s number is smaller than both player 2’s and player 3’s. If so, then player 1 is the winner. If not, we do the same for player 2’s number. If neither player 1 nor player 2 has the smallest number, then we can assume that player 3 is the winner without even checking.\nAs it turns out, we would end up using the exact same code in the situation where all numbers are odd, so for now we can just copy and paste that set of conditional statements there as well:\np1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") elif p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") elif p1 % 2 == 0 and p2 % 2 == 0 and p3 % 2 == 0: if p1 \u003c p2 and p1 \u003c p3: print(\"Player 1 wins\") elif p2 \u003c p1 and p2 \u003c p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") elif p1 % 2 != 0 and p2 % 2 != 0 and p3 % 2 != 0: if p1 \u003c p2 and p1 \u003c p3: print(\"Player 1 wins\") elif p2 \u003c p1 and p2 \u003c p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") else: print(\"Numbers are both even and odd\") That covers the situations where all players have input either even or odd numbers. We can quickly test this program a couple of times by providing various inputs that match those cases. So, when we run this program, we should see output like this:\nDetermining the Largest Number The last step is to determine the largest number in the case that the numbers are not all even or odd. Since we’ve already written some code to handle the opposite case, let’s quickly copy and tweak that code to handle this case. We can then place that code False branch of our conditional statement handling the logic of the program:\np1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") elif p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") elif p1 % 2 == 0 and p2 % 2 == 0 and p3 % 2 == 0: if p1 \u003c p2 and p1 \u003c p3: print(\"Player 1 wins\") elif p2 \u003c p1 and p2 \u003c p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") elif p1 % 2 != 0 and p2 % 2 != 0 and p3 % 2 != 0: if p1 \u003c p2 and p1 \u003c p3: print(\"Player 1 wins\") elif p2 \u003c p1 and p2 \u003c p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") else: if p1 \u003e p2 and p1 \u003e p3: print(\"Player 1 wins\") elif p2 \u003e p1 and p2 \u003e p3: print(\"Player 2 wins\") else: print(\"Player 3 wins\") There we go! We’ve written a complete program that implements the problem statement given above. Did you think it would end up being this complex? Sometimes even a simple problem statement ends up requiring quite a bit of code to implement it fully.\nTesting - Branch Coverage The next step is to perform some testing of our program to make sure it is fully working. To do that, we need to come up with a set of inputs that would achieve branch coverage, and possibly even path coverage. However, this time our program is spread across three different sets of conditional statements, so it makes it a bit more difficult to do. So, let’s focus on each individual statement separately and see if we can find a set that work for each of them.\nTop-Level Statement First, we see the top-level statement has 5 branches to cover, so we need to come up with 5 different sets of inputs in order to achieve branch coverage. We can keep the inputs very small, just to make our testing a bit simpler. Here are the 5 branches to cover, and an input that will reach each one:\nInvalid input: -1, -1, -1 Tie: 1, 1, 1 All Even: 2, 4, 6 All Odd: 1, 3, 5 Mixed: 1, 2, 3 Notice how we are trying to come up with the simplest possible inputs for each branch? That will make it easier to combine these inputs with the ones used in other conditional statements to find an overall set of inputs that will achieve branch coverage for the entire program.\nSmallest Statements Next, we can look at the code to find the smallest number. This code is used when the inputs are either all even or all odd. So, we know that either inputs 2, 4, 6 or 1, 3, 5 will execute this code.\nWithin the code itself, we see three branches, depending on which player wins. So, if we start with the input 2, 4, 6, we’ll see that this will execute the branch where player 1 wins. To execute the other branches, we can simply reorder the inputs:\nPlayer 1 Wins: 2, 4, 6 Player 2 Wins: 4, 2, 6 Player 3 Wins: 4, 6, 2 That will achieve branch coverage for the “smallest” conditional statement, and even overlaps with one of the inputs used in the top-level statement.\nLargest Statement The same applies to the conditional statement to find the largest number, but in this case we need a mix of even and odd numbers in the input. So, the input 1, 2, 3 will execute this code, and that input results in player 3 winning. Once again, we can reorder that input a bit to execute all three branches of this code:\nPlayer 1 Wins: 3, 1, 2 Player 2 Wins: 1, 3, 2 Player 3 Wins: 1, 2, 3 Overall Program Therefore, based on our analysis, we can achieve branch coverage across the entire program using 9 different inputs:\nInvalid input: -1, -1, -1 Tie: 1, 1, 1 All Even: Player 1 Wins: 2, 4, 6 Player 2 Wins: 4, 2, 6 Player 3 Wins: 4, 6, 2 All Odd: 1, 3, 5 Mixed: Player 1 Wins: 3, 1, 2 Player 2 Wins: 1, 3, 2 Player 3 Wins: 1, 2, 3 This will execute each branch of all conditional statements in the program at least once.\nPath Coverage Once we’ve achieved branch coverage, we should also quickly look at path coverage: is there any possible pathway through this program that we haven’t tested yet? As it turns out, there are two, but they are somewhat difficult to find. Can you spot them? See if you can figure it out before continuing on in this page.\nThe paths we missed are situations where the numbers are all odd, but a player other than player 1 wins. While we tested all possible branches in the “smallest” conditional statement, we didn’t test it using all odd numbers more than once. So, to truly achieve path coverage, we should add two more inputs to our list above:\nInvalid input: -1, -1, -1 Tie: 1, 1, 1 All Even: Player 1 Wins: 2, 4, 6 Player 2 Wins: 4, 2, 6 Player 3 Wins: 4, 6, 2 All Odd: Player 1 Wins: 1, 3, 5 Player 2 Wins: 3, 1, 5 Player 3 Wins: 3, 5, 1 Mixed: Player 1 Wins: 3, 1, 2 Player 2 Wins: 1, 3, 2 Player 3 Wins: 1, 2, 3 So, with a total of 11 inputs, we can finally say we’ve achieved both branch coverage and path coverage of this program.\n",
    "description": "",
    "tags": null,
    "title": "Worked Example",
    "uri": "/04-conditionals/14-example/"
  },
  {
    "content": "Let’s try some simple practice problems. These problems are not graded - they are just for you to practice before doing the real exercises in the lab itself. You can find the answers below each question by clicking the button below each question.\n4.11 Reading Code Consider the following Python program:\np1 = int(input(\"Enter a positive integer for player 1: \")) p2 = int(input(\"Enter a positive integer for player 2: \")) p3 = int(input(\"Enter a positive integer for player 3: \")) if p1 \u003c= 0 or p2 \u003c= 0 or p3 \u003c= 0: print(\"Error\") else: twos = (p1 + p2 + p3) // 2 threes = (p1 + p2 + p3) // 3 fours = (p1 + p2 + p3) // 4 if p1 == p2 or p2 == p3 or p3 == p1: print(\"Tie\") elif p1 != twos and p2 != threes and p3 != fours: print(\"Draw\") else: if p1 == twos: print(\"Player 1 Wins\") if p2 == threes: print(\"Player 2 Wins\") if p3 == fours: print(\"Player 3 Wins\") Explain, in your own words, a set of rules for the game that this program is simulating.\nA fully correct answer is a succinct set of rules for the game and what leads to the various outcomes. A partially correct answer is a step-by-step description of each line in the program and the output it will produce based on the input.\nHint: it is possible for multiple players to win a round in this game.\nAnswer 4.11 Answer One way to express the rules of this game is given below:\nThree players each guess a positive integer greater than $ 0 $, and then share them simultaneously. The winner is chosen following this formula:\nIf any two players have chosen the same number, the game is a tie. Otherwise, compute the sum of the three numbers, and then determine the number of twos, threes, and fours that fit in that number. (Mathematically, perform division and round down.) If player 1 correctly guesses the number of twos in the sum, they win. If player 2 correctly guesses the number of threes in the sum, they win. If player 3 correctly guesses the number of fours in the sum, they win. It is possible for multiple players to win. If no players have won, then the game is a draw. 4.12 Testing Code Consider the Python program in the question above. Give a set of inputs that will achieve branch coverage for this program. You do not have to achieve path coverage!\nHint: try 3, 2, 1 as one possible input. What branches will that execute?\nAnswer 4.12 Answer To achieve branch coverage, the following inputs can be used:\nError: -1, -1, -1 Tie: 1, 1, 1 Draw: 2, 1, 3 All Win: 3, 2, 1 This does not achieve path coverage. To do that, you’d need to come up with a set of inputs that result in all possible combinations of players winning. The rules of this game make that a bit difficult to do easily.\n4.13 Writing Code Write a complete Python program that meets the specification below.\nA childcare supervisor has developed a set of rules to determine if children under their care may play indoors or outdoors. Here are the rules:\nIf it is raining, then the children must play indoors since they’ll get wet. This rule takes precedence over all other rules. If the temperature is below 0° C, then the children must play indoors because it is too cold, unless there is snow on the ground. In that case, children may play both indoors and outdoors. If the temperature is above 40° C, then the children must play indoors because it is too hot, unless the pool is open. In that case, children may play both indoors and outdoors. If the temperature is between 20° C and 30° C, then the children must play outdoors because it is a nice day. Otherwise, if no other rules are matched, children may choose to play both indoors and outdoors. Write a program that will help determine if the children may play indoors, outdoors, or both. The program will prompt the user for four inputs in the following order:\nThe temperature as an integer (measured in degrees Celsius). Whether it is raining: yes or no. Whether there is snow on the ground: yes or no. Whether the pool is open: yes or no. The program should output either indoors, outdoors, or both, depending on the rules described above. Your program must make use of chained and/or nested conditional statements.\nHint: after reading input, the yes and no answers can be converted to Boolean values once and stored in Boolean variables. This will simplify the Boolean expressions used in the conditional statements.\nAnswer 4.13 Answer Below is one possible solution:\ntemperature = int(input(\"Enter the temperature in degrees Celsius: \")) raining = input(\"Is it raining? 'yes' or 'no': \") == \"yes\" snow = input(\"Is there snow on the ground? 'yes' or 'no': \") == \"yes\" pool = input(\"Is the pool open? 'yes' or 'no': \") == \"yes\" if raining: print(\"indoors\") else: if temperature \u003c 0: if snow: print(\"both\") else: print(\"indoors\") elif temperature \u003e 40: if pool: print(\"both\") else: print(\"indoors\") elif 20 \u003c temperature and temperature \u003c 30: print(\"outdoors\") else: print(\"both\") Notice that it immediately checks if the inputs of yes or no are equal to yes, which will convert them to a Boolean value. Then, in the conditional statements, Boolean values can be used without any operators.\n",
    "description": "",
    "tags": null,
    "title": "Nesting Practice",
    "uri": "/04-conditionals/15-nesting-practice/"
  },
  {
    "content": "In this lab, we introduced several major important topics in Python. Let’s quickly review them.\nBooleans in Python True False bool() procedure to convert values If the input is the value False, the value 0, the value None, or anything with 0 length, including the empty string, it will return False. Otherwise, for all other values it will return True. Boolean Operators and or not Boolean Comparators == equal != not equal \u003c less than \u003c= less than or equal to \u003e greater than \u003e= greater than or equal to Comparators and Strings Strings are compared using lexicographic order\nBoolean Order of Operations Math operators (following their order of operations) Boolean comparators not and or Conditional Statements if statement if \u003cboolean expression\u003e: \u003cblock of statements\u003e if-else statement if \u003cboolean expression\u003e: \u003cblock of statements 1\u003e else: \u003cblock of statements 2\u003e Testing Branch Coverage - all possible branches are executed at least once Path Coverage - all possible paths through branches are executed at least once Edge Cases - values that are near the point where Boolean expressions go from False to True Mutually Exclusive Conditional statements are mutually exclusive when only one of the many branches will be executed for any possible input.\nChained Conditionals if condition_1: print(\"1\") else if condition_2: print(\"2\") else: if condition_3: print(\"3\") else: print(\"4\") is equivalent to:\nif condition_1: print(\"1\") elif condition_2: print(\"2\") elif condition_3: print(\"3\") else: print(\"4\") Nested Conditionals if condition_1: if condition_2: print(\"1 and 2\") elif condition_3: print(\"1 and 3\") else: print(\"1 and not 2 or 3\") elif condition_4: if condition_2: print(\"4 and 2\") elif condition_3: print(\"4 and 3\") else: print(\"4 and not 2 or 3\") else: print(\"neither 1 nor 4\") Variable Scope Variable scope refers to what parts of the code a particular variable is accessible in. Python uses function scope, which means that a variable defined anywhere in a function is available below that definition in any part of the same function.\nOther languages use block scope, where variables are only available within the block where they are defined.\n",
    "description": "",
    "tags": null,
    "title": "Summary",
    "uri": "/04-conditionals/16-summary/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/"
  },
  {
    "content": "Chapter 0 Introduction Welcome to the Introduction to Python textbook!\n",
    "description": "",
    "tags": null,
    "title": "Introduction",
    "uri": "/00-introduction/"
  },
  {
    "content": "This textbook is used by CIS 115, CC 111, CC 711, and the Cyber Pipeline outreach program to teach basic Python programming to first-time programmers.\n",
    "description": "",
    "tags": null,
    "title": "Introduction to Python",
    "uri": "/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/"
  }
]
